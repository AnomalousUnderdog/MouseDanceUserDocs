{
  "api/MouseDance.Demo.BasicDemoMain.html": {
    "href": "api/MouseDance.Demo.BasicDemoMain.html",
    "title": "Class BasicDemoMain | MouseDance User Docs",
    "keywords": "Class BasicDemoMain Simple code usage of MouseDance to run a Beatmap. This plays a countdown animation and then shows a simple Results screen afterwards. Inheritance Object Object Component Behaviour MonoBehaviour BasicDemoMain BasicDemoWithAltHitCircleMain BasicDemoWithEQMain BasicDemoWithHardRockMain DynamicDifficultyDemoMain LeftRightClickDemoMain Implements ISongStartCountdown IBeatmapEnd Namespace : MouseDance.Demo Assembly : MouseDance.Demo.dll Syntax public class BasicDemoMain : MonoBehaviour, ISongStartCountdown, IBeatmapEnd Fields _beatmapRunner Declaration [SerializeField] protected BeatmapRunner _beatmapRunner Field Value Type Description BeatmapRunner Properties CountdownLength Declaration public float CountdownLength { get; } Property Value Type Description Single Methods Awake() Declaration protected virtual void Awake() OnBeatmapEnd(IBeatmapResults) Declaration public void OnBeatmapEnd(IBeatmapResults results) Parameters Type Name Description IBeatmapResults results OnStartCountdown() Declaration public void OnStartCountdown() Pause(Boolean) Called when user presses the pause button in the UI. See Show() . Declaration public void Pause(bool pause) Parameters Type Name Description Boolean pause Restart() Called by OptionsDisplay when user clicks on the Restart button. Declaration public virtual void Restart() StartGame() Declaration public void StartGame() Implements ISongStartCountdown IBeatmapEnd Extension Methods Util.SetLayerDeep(Component, LayerMask) Util.SetLayerDeep(Component, Int32) Util.SetLayerDeep(Component, LayerMask, Stack<Transform>)"
  },
  "api/MouseDance.Demo.BasicDemoWithAltHitCircleMain.html": {
    "href": "api/MouseDance.Demo.BasicDemoWithAltHitCircleMain.html",
    "title": "Class BasicDemoWithAltHitCircleMain | MouseDance User Docs",
    "keywords": "Class BasicDemoWithAltHitCircleMain This example shows how to use IHitObjectSizeCalculator to make the Hit Objects get increasingly smaller as we go further along the combo counter. On a new combo, it resets to the largest size. Inheritance Object Object Component Behaviour MonoBehaviour BasicDemoMain BasicDemoWithAltHitCircleMain Implements ISongStartCountdown IBeatmapEnd IHitObjectSizeCalculator Inherited Members BasicDemoMain._beatmapRunner BasicDemoMain.StartGame() BasicDemoMain.Pause(Boolean) BasicDemoMain.Restart() BasicDemoMain.OnStartCountdown() BasicDemoMain.CountdownLength BasicDemoMain.OnBeatmapEnd(IBeatmapResults) Namespace : MouseDance.Demo Assembly : MouseDance.Demo.dll Syntax public class BasicDemoWithAltHitCircleMain : BasicDemoMain, ISongStartCountdown, IBeatmapEnd, IHitObjectSizeCalculator Remarks Note that this is a subclass of BasicDemoMain , so all the callbacks that BasicDemoMain registers will also be done by this subclass ( ISongStartCountdown to show a countdown animation, and IBeatmapEnd to show a Results screen afterwards). Methods Awake() Declaration protected override void Awake() Overrides BasicDemoMain.Awake() GetHitCircleRadius(Int32, Int32, Int32, HitCircle, Beatmap) Declaration public float GetHitCircleRadius(int idx, int comboCounter, int comboColourIdx, HitCircle hitCircle, Beatmap beatmap) Parameters Type Name Description Int32 idx Int32 comboCounter Int32 comboColourIdx OsuParsers.Beatmaps.Objects.HitCircle hitCircle OsuParsers.Beatmaps.Beatmap beatmap Returns Type Description Single GetSliderCircleRadius(Int32, Int32, Int32, Slider, Beatmap) Declaration public float GetSliderCircleRadius(int idx, int comboCounter, int comboColourIdx, Slider slider, Beatmap beatmap) Parameters Type Name Description Int32 idx Int32 comboCounter Int32 comboColourIdx OsuParsers.Beatmaps.Objects.Slider slider OsuParsers.Beatmaps.Beatmap beatmap Returns Type Description Single Implements ISongStartCountdown IBeatmapEnd IHitObjectSizeCalculator Extension Methods Util.SetLayerDeep(Component, LayerMask) Util.SetLayerDeep(Component, Int32) Util.SetLayerDeep(Component, LayerMask, Stack<Transform>)"
  },
  "api/MouseDance.Demo.BasicDemoWithEQMain.AudioVisualizerMode.html": {
    "href": "api/MouseDance.Demo.BasicDemoWithEQMain.AudioVisualizerMode.html",
    "title": "Enum BasicDemoWithEQMain.AudioVisualizerMode | MouseDance User Docs",
    "keywords": "Enum BasicDemoWithEQMain.AudioVisualizerMode Namespace : MouseDance.Demo Assembly : MouseDance.Demo.dll Syntax public enum AudioVisualizerMode Fields Name Description Frequency None Waveform"
  },
  "api/MouseDance.Demo.BasicDemoWithEQMain.html": {
    "href": "api/MouseDance.Demo.BasicDemoWithEQMain.html",
    "title": "Class BasicDemoWithEQMain | MouseDance User Docs",
    "keywords": "Class BasicDemoWithEQMain Simple code usage of MouseDance to run a Beatmap, but also updates an equalizer display while the song plays. Inheritance Object Object Component Behaviour MonoBehaviour BasicDemoMain BasicDemoWithEQMain Implements ISongStartCountdown IBeatmapEnd Inherited Members BasicDemoMain._beatmapRunner BasicDemoMain.Awake() BasicDemoMain.StartGame() BasicDemoMain.Pause(Boolean) BasicDemoMain.OnStartCountdown() BasicDemoMain.CountdownLength BasicDemoMain.OnBeatmapEnd(IBeatmapResults) Namespace : MouseDance.Demo Assembly : MouseDance.Demo.dll Syntax public class BasicDemoWithEQMain : BasicDemoMain, ISongStartCountdown, IBeatmapEnd Methods Restart() Declaration public override void Restart() Overrides BasicDemoMain.Restart() Implements ISongStartCountdown IBeatmapEnd Extension Methods Util.SetLayerDeep(Component, LayerMask) Util.SetLayerDeep(Component, Int32) Util.SetLayerDeep(Component, LayerMask, Stack<Transform>)"
  },
  "api/MouseDance.Demo.BasicDemoWithHardRockMain.html": {
    "href": "api/MouseDance.Demo.BasicDemoWithHardRockMain.html",
    "title": "Class BasicDemoWithHardRockMain | MouseDance User Docs",
    "keywords": "Class BasicDemoWithHardRockMain Simple code usage of IBeatmapLoaded to modify a Beatmap that mimics the effects of the Hard Rock modifier before playing the Beatmap (check OnBeatmapLoaded(Beatmap) ). Inheritance Object Object Component Behaviour MonoBehaviour BasicDemoMain BasicDemoWithHardRockMain Implements ISongStartCountdown IBeatmapEnd IBeatmapLoaded Inherited Members BasicDemoMain._beatmapRunner BasicDemoMain.StartGame() BasicDemoMain.Pause(Boolean) BasicDemoMain.Restart() BasicDemoMain.OnStartCountdown() BasicDemoMain.CountdownLength BasicDemoMain.OnBeatmapEnd(IBeatmapResults) Namespace : MouseDance.Demo Assembly : MouseDance.Demo.dll Syntax public class BasicDemoWithHardRockMain : BasicDemoMain, ISongStartCountdown, IBeatmapEnd, IBeatmapLoaded Remarks Note that this is a subclass of BasicDemoMain , so all the callbacks that BasicDemoMain registers will also be done by this subclass ( ISongStartCountdown to show a countdown animation, and IBeatmapEnd to show a Results screen afterwards). Methods Awake() Declaration protected override void Awake() Overrides BasicDemoMain.Awake() OnBeatmapLoaded(Beatmap) Called after a beatmap has been loaded (with LoadAndStart, which is called by our parent class BasicDemoMain ) but right before the game is actually started. This is used to edit the beatmap that is loaded in memory as much as we want before it is used. We call SetOnBeatmapLoaded(IBeatmapLoaded) before the game is started for this to work. Declaration public void OnBeatmapLoaded(Beatmap beatmap) Parameters Type Name Description OsuParsers.Beatmaps.Beatmap beatmap Editable reference to the beatmap. Remarks This is only called once for every beatmap that has just been loaded. It is not called repeatedly on the same beatmap when the song is restarted. Implements ISongStartCountdown IBeatmapEnd IBeatmapLoaded Extension Methods Util.SetLayerDeep(Component, LayerMask) Util.SetLayerDeep(Component, Int32) Util.SetLayerDeep(Component, LayerMask, Stack<Transform>)"
  },
  "api/MouseDance.Demo.DynamicDifficultyDemoMain.html": {
    "href": "api/MouseDance.Demo.DynamicDifficultyDemoMain.html",
    "title": "Class DynamicDifficultyDemoMain | MouseDance User Docs",
    "keywords": "Class DynamicDifficultyDemoMain Example of custom rules in the game. This one shrinks Hit Object size on every successful hit (you can change the frequency of it with MouseDance.Demo.DynamicDifficultyDemoMain._shrinkFrequency ). Inheritance Object Object Component Behaviour MonoBehaviour BasicDemoMain DynamicDifficultyDemoMain Implements ISongStartCountdown IBeatmapEnd IBeatmapLoaded IHitObjectSizeCalculator IClickedHitObject Inherited Members BasicDemoMain._beatmapRunner BasicDemoMain.StartGame() BasicDemoMain.Pause(Boolean) BasicDemoMain.OnStartCountdown() BasicDemoMain.CountdownLength BasicDemoMain.OnBeatmapEnd(IBeatmapResults) Namespace : MouseDance.Demo Assembly : MouseDance.Demo.dll Syntax public class DynamicDifficultyDemoMain : BasicDemoMain, ISongStartCountdown, IBeatmapEnd, IBeatmapLoaded, IHitObjectSizeCalculator, IClickedHitObject Remarks If the player misses, the size resets. Note that this goes all the way up to Circle Size Difficulty of 10 ( Osu! Beatmap Editor will only allow you to go up to 7). Also note that this is a subclass of BasicDemoMain , so all the callbacks that BasicDemoMain registers will also be done by this subclass ( ISongStartCountdown to show a countdown animation, and IBeatmapEnd to show a Results screen afterwards). Methods Awake() Declaration protected override void Awake() Overrides BasicDemoMain.Awake() GetHitCircleRadius(Int32, Int32, Int32, HitCircle, Beatmap) Determine what radius will be for this Hit Circle. Declaration public float GetHitCircleRadius(int idx, int comboCounter, int comboColourIdx, HitCircle hitCircle, Beatmap beatmap) Parameters Type Name Description Int32 idx Index position of the Hit Circle in the entire Beatmap. Starts at 0. Int32 comboCounter Number to be displayed on the Hit Circle. Int32 comboColourIdx What index of colour this Hit Circle is given. Starts at 0. OsuParsers.Beatmaps.Objects.HitCircle hitCircle Extra info about the Hit Circle. OsuParsers.Beatmaps.Beatmap beatmap Data on the entire Beatmap. Returns Type Description Single Radius (in osu!pixels) that the Hit Circle will be in. GetSliderCircleRadius(Int32, Int32, Int32, Slider, Beatmap) Determine what radius will be for this Slider. Declaration public float GetSliderCircleRadius(int idx, int comboCounter, int comboColourIdx, Slider slider, Beatmap beatmap) Parameters Type Name Description Int32 idx Index position of this Slider in the entire Beatmap. Starts at 0. Int32 comboCounter Combo Number to be displayed on the Slider. Int32 comboColourIdx What index of colour this Slider is given. Starts at 0. OsuParsers.Beatmaps.Objects.Slider slider Extra info about the Slider. OsuParsers.Beatmaps.Beatmap beatmap Data on the entire Beatmap. Returns Type Description Single Radius (in osu!pixels) that the Slider will be in. OnBeatmapLoaded(Beatmap) Called after a beatmap has been loaded (with LoadAndStart) but right before the game is actually started. This can be used to edit the beatmap as much as you want before it is used. Make sure you call SetOnBeatmapLoaded(IBeatmapLoaded) before the game is started so that this actually gets called. Declaration public void OnBeatmapLoaded(Beatmap beatmap) Parameters Type Name Description OsuParsers.Beatmaps.Beatmap beatmap Editable reference to the beatmap. Remarks This is only called once for every .osu file that has just been loaded. It is not called repeatedly when the song is restarted. OnClickedHitCircle(Int32, Int32, Single, Int32, Beatmap) Called by the BeatmapRunner when player clicks on a Hit Circle. Declaration public void OnClickedHitCircle(int idxClicked, int idxThatNeedsToBePressed, float result, int gotBaseScore, Beatmap beatmap) Parameters Type Name Description Int32 idxClicked Index of Hit Circle pressed. Int32 idxThatNeedsToBePressed Index of Hit Object that needs to be pressed. If this doesn't match idxPressed, then player clicked on something they shouldn't yet. Single result Normalized value indicating if user pressed Hit Circle within correct time window. -1.0 to +1.0 is a hit. Any value outside that (lesser than -1.0 or greater than +1.0) means miss (negative for too early, positive for too late). 0.0 means user pressed exactly at Hit Circle's hit time. Int32 gotBaseScore The 50, 100, or 300 score that the press of this Hit Circle got. This value is not directly added to the player's score yet (because score will still be multiplied), just a representation of which time window the player pressed. OsuParsers.Beatmaps.Beatmap beatmap Data of the entire beatmap. Use beatmap.HitObjects[idxPressed] to get more data about the Hit Circle. OnClickedSliderHead(Int32, Int32, Single, Int32, Beatmap) Called by the BeatmapRunner when player clicks on a Slider head/start cap. Declaration public void OnClickedSliderHead(int idxClicked, int idxThatNeedsToBePressed, float result, int gotBaseScore, Beatmap beatmap) Parameters Type Name Description Int32 idxClicked Index of Slider pressed. Int32 idxThatNeedsToBePressed Index of Hit Object that needs to be pressed. If this doesn't match idxPressed, then player clicked on something they shouldn't yet. Single result Normalized value indicating if user pressed slider's head within correct time window. -1.0 to +1.0 is a hit. Any value outside that (lesser than -1.0 or greater than +1.0) means miss (negative for too early, positive for too late). 0.0 means user pressed exactly at slider head's hit time. Int32 gotBaseScore The equivalent 50, 100, or 300 score that the press of this Slider Head would get. This score is not added to the player's score, just a representation of which time window the player pressed. OsuParsers.Beatmaps.Beatmap beatmap Data of the entire beatmap. Use beatmap.HitObjects[idxPressed] to get more data about the Slider. OnHitCircleDieOff(Int32, Beatmap) Called by the BeatmapRunner when a Hit Circle's time is up and player never clicked on it. Declaration public void OnHitCircleDieOff(int hitCircleIdx, Beatmap beatmap) Parameters Type Name Description Int32 hitCircleIdx Hit Circle's Index among the entire beatmap. OsuParsers.Beatmaps.Beatmap beatmap Data of the entire beatmap. Use beatmap.HitObjects[hitCircleIdx] to get more data about the Hit Circle. OnSliderFinished(Int32, Single, Beatmap) Called when a Slider has finished (ball finished rolling through it). Declaration public void OnSliderFinished(int sliderIdx, float completionPercent, Beatmap beatmap) Parameters Type Name Description Int32 sliderIdx Index of Slider that was finished. Single completionPercent 0.0 to 1.0 value of percent completion. 0.0 means 0%, 1.0 means 100%, 0.5 means 50%, etc. OsuParsers.Beatmaps.Beatmap beatmap Data of the entire beatmap. Use beatmap.HitObjects[sliderIdx] to get more data about the Slider. Restart() Declaration public override void Restart() Overrides BasicDemoMain.Restart() Implements ISongStartCountdown IBeatmapEnd IBeatmapLoaded IHitObjectSizeCalculator IClickedHitObject Extension Methods Util.SetLayerDeep(Component, LayerMask) Util.SetLayerDeep(Component, Int32) Util.SetLayerDeep(Component, LayerMask, Stack<Transform>)"
  },
  "api/MouseDance.Demo.Editor.html": {
    "href": "api/MouseDance.Demo.Editor.html",
    "title": "Namespace MouseDance.Demo.Editor | MouseDance User Docs",
    "keywords": "Namespace MouseDance.Demo.Editor Classes SquaresInspector"
  },
  "api/MouseDance.Demo.Editor.SquaresInspector.html": {
    "href": "api/MouseDance.Demo.Editor.SquaresInspector.html",
    "title": "Class SquaresInspector | MouseDance User Docs",
    "keywords": "Class SquaresInspector Inheritance Object Object ScriptableObject Editor UnityEditor.UI.GraphicEditor UnityEditor.UI.ImageEditor SquaresInspector Namespace : MouseDance.Demo.Editor Assembly : MouseDance.Demo.Editor.dll Syntax [CustomEditor(typeof(Squares))] public class SquaresInspector : ImageEditor Methods OnInspectorGUI() Declaration public override void OnInspectorGUI() Overrides UnityEditor.UI.ImageEditor.OnInspectorGUI()"
  },
  "api/MouseDance.Demo.html": {
    "href": "api/MouseDance.Demo.html",
    "title": "Namespace MouseDance.Demo | MouseDance User Docs",
    "keywords": "Namespace MouseDance.Demo Code meant to illustrate how MouseDance is used. You can delete this and/or keep the code you find useful for your own project. Classes BasicDemoMain Simple code usage of MouseDance to run a Beatmap. This plays a countdown animation and then shows a simple Results screen afterwards. BasicDemoWithAltHitCircleMain This example shows how to use IHitObjectSizeCalculator to make the Hit Objects get increasingly smaller as we go further along the combo counter. On a new combo, it resets to the largest size. BasicDemoWithEQMain Simple code usage of MouseDance to run a Beatmap, but also updates an equalizer display while the song plays. BasicDemoWithHardRockMain Simple code usage of IBeatmapLoaded to modify a Beatmap that mimics the effects of the Hard Rock modifier before playing the Beatmap (check OnBeatmapLoaded(Beatmap) ). DynamicDifficultyDemoMain Example of custom rules in the game. This one shrinks Hit Object size on every successful hit (you can change the frequency of it with MouseDance.Demo.DynamicDifficultyDemoMain._shrinkFrequency ). LeftRightClickDemoMain Example of how to add custom rules to the game. Used in the Left Right Click Demo. It uses IBeatmapInput to change how input is detected, and ICustomCollectRule to change the rules on how Hit Objects are collected. LeftRightClickHitObjectSet Example of how to make the game instantiate a differently shaped Hit Object based on the rules. Used in the Left Right Click Demo. When the Hit Object is coloured red, we'll instantiate the regular Hit Objects. When the Hit Object is coloured blue, we'll instantiate a different shape of Hit Objects. Just like in LeftRightClickDemoMain , we're assuming the colours are assigned properly, wherein there are only two combo colours, red and blue. So we can easily figure it out based on the Combo Colour Index: 0 for red, 1 for blue. MainMenu MyHitObjectSet Sample sub-class of HitObjectSet to show how you can change prefab instantiation rules. OptionsDisplay Handles showing/hiding an Options window, also handles user-input on the buttons of the Options window. ResultsDisplay Handles showing a screen that displays player score at the end of the game. SceneButton SceneList SceneList.Entry SliderTest Hardcoded tests to show some SDF curves Squares Renders many squares on-screen meant for EQ display, using Unity UI. TestSDF2Line TestSDF3Line TestSDFCurve TestSDFLine Enums BasicDemoWithEQMain.AudioVisualizerMode"
  },
  "api/MouseDance.Demo.LeftRightClickDemoMain.html": {
    "href": "api/MouseDance.Demo.LeftRightClickDemoMain.html",
    "title": "Class LeftRightClickDemoMain | MouseDance User Docs",
    "keywords": "Class LeftRightClickDemoMain Example of how to add custom rules to the game. Used in the Left Right Click Demo. It uses IBeatmapInput to change how input is detected, and ICustomCollectRule to change the rules on how Hit Objects are collected. Inheritance Object Object Component Behaviour MonoBehaviour BasicDemoMain LeftRightClickDemoMain Implements ISongStartCountdown IBeatmapEnd IBeatmapInput ICustomCollectRule Inherited Members BasicDemoMain._beatmapRunner BasicDemoMain.StartGame() BasicDemoMain.Pause(Boolean) BasicDemoMain.Restart() BasicDemoMain.OnStartCountdown() BasicDemoMain.CountdownLength BasicDemoMain.OnBeatmapEnd(IBeatmapResults) Namespace : MouseDance.Demo Assembly : MouseDance.Demo.dll Syntax public class LeftRightClickDemoMain : BasicDemoMain, ISongStartCountdown, IBeatmapEnd, IBeatmapInput, ICustomCollectRule Remarks We'll require left-click when the Hit Object is red, and right-click when the Hit Object is blue. We're assuming the Combo Colours are assigned properly (in HitObjectColours ), wherein there are only two combo colours, red and blue. So we can easily figure it out based on the Combo Colour Index: 0 for red, 1 for blue. Also note that this is a subclass of BasicDemoMain , so all the callbacks that BasicDemoMain registers will also be done by this subclass ( ISongStartCountdown to show a countdown animation, and IBeatmapEnd to show a Results screen afterwards). Properties CursorPosition Declaration public Vector2 CursorPosition { get; } Property Value Type Description Vector2 IsPlayerInputDown Declaration public bool IsPlayerInputDown { get; } Property Value Type Description Boolean IsPlayerInputUp Declaration public bool IsPlayerInputUp { get; } Property Value Type Description Boolean Methods AllowCollect(IHitObject, IReadOnlyList<IHitObject>) Called by the BeatmapRunner to check if player is allowed to proceed with pressing the Hit Object they clicked on. Declaration public HitObjectReaction AllowCollect(IHitObject hitObject, IReadOnlyList<IHitObject> allPressed) Parameters Type Name Description IHitObject hitObject The Hit Object we are checking. IReadOnlyList < IHitObject > allPressed List of all Hit Objects pressed, in case player pressed on overlapping Hit Objects. This is sorted by Hit Object Index meaning first element in this list is the one that is visually topmost (in terms of Z-order) on the screen. If there is only one Hit Object pressed, then allPressed will only contain one element. Returns Type Description HitObjectReaction HitObjectReaction struct containing all info on how you want the Hit Object to react. Remarks This is called the same frame that IsPlayerInputDown returns true. It is called for each Hit Object found under the mouse (in case the player clicked on overlapping Hit Objects). AllowCollectSliderPart(IHitObject) Called by the BeatmapRunner to check if player is allowed to proceed with collecting a Slider Part that they're currently pressing on. Declaration public bool AllowCollectSliderPart(IHitObject slider) Parameters Type Name Description IHitObject slider The Slider we're checking for. Returns Type Description Boolean Return true to allow the Slider Part to be collected. Awake() Declaration protected override void Awake() Overrides BasicDemoMain.Awake() Implements ISongStartCountdown IBeatmapEnd IBeatmapInput ICustomCollectRule Extension Methods Util.SetLayerDeep(Component, LayerMask) Util.SetLayerDeep(Component, Int32) Util.SetLayerDeep(Component, LayerMask, Stack<Transform>)"
  },
  "api/MouseDance.Demo.LeftRightClickHitObjectSet.html": {
    "href": "api/MouseDance.Demo.LeftRightClickHitObjectSet.html",
    "title": "Class LeftRightClickHitObjectSet | MouseDance User Docs",
    "keywords": "Class LeftRightClickHitObjectSet Example of how to make the game instantiate a differently shaped Hit Object based on the rules. Used in the Left Right Click Demo. When the Hit Object is coloured red, we'll instantiate the regular Hit Objects. When the Hit Object is coloured blue, we'll instantiate a different shape of Hit Objects. Just like in LeftRightClickDemoMain , we're assuming the colours are assigned properly, wherein there are only two combo colours, red and blue. So we can easily figure it out based on the Combo Colour Index: 0 for red, 1 for blue. Inheritance Object Object ScriptableObject HitObjectSet LeftRightClickHitObjectSet Inherited Members HitObjectSet.HitCirclePrefab HitObjectSet.SliderPrefab HitObjectSet.SliderTickPrefab HitObjectSet.SliderBallPrefab HitObjectSet.SdfCurvePrefab Namespace : MouseDance.Demo Assembly : MouseDance.Demo.dll Syntax [CreateAssetMenu(fileName = \"LeftRightClickHitObjectSet\", menuName = \"MouseDance/LeftRightClickHitObjectSet\")] public class LeftRightClickHitObjectSet : HitObjectSet Fields HitCirclePrefabForRightClick Declaration [Header(\"Additional Hit Objects\")] [Tooltip(\"Master-copy of the Hit Circle prefab that will be spawned and pooled when right-click is needed.\")] public HitCircle HitCirclePrefabForRightClick Field Value Type Description HitCircle SliderBallPrefabForRightClick Declaration [Tooltip(\"Master-copy of the Slider Ball prefab when right-click is needed. Used by Sliders.\")] public SliderBall SliderBallPrefabForRightClick Field Value Type Description SliderBall SliderPrefabForRightClick Declaration [Tooltip(\"Master-copy of the Slider prefab that will be spawned and pooled when right-click is needed.\")] public Slider SliderPrefabForRightClick Field Value Type Description Slider Methods GetHitCirclePrefab(Int32, Int32, Int32, HitCircle, Beatmap) Declaration public override (string, HitCircle) GetHitCirclePrefab(int idx, int comboCounter, int comboColourIdx, HitCircle hitCircle, Beatmap beatmap) Parameters Type Name Description Int32 idx Int32 comboCounter Int32 comboColourIdx OsuParsers.Beatmaps.Objects.HitCircle hitCircle OsuParsers.Beatmaps.Beatmap beatmap Returns Type Description (T1, T2) < String , HitCircle > Overrides HitObjectSet.GetHitCirclePrefab(Int32, Int32, Int32, HitCircle, Beatmap) GetSliderBallPrefab(String) Declaration public override SliderBall GetSliderBallPrefab(string poolId) Parameters Type Name Description String poolId Returns Type Description SliderBall Overrides HitObjectSet.GetSliderBallPrefab(String) GetSliderPrefab(Int32, Int32, Int32, Slider, Beatmap) Declaration public override (string, Slider) GetSliderPrefab(int idx, int comboCounter, int comboColourIdx, Slider slider, Beatmap beatmap) Parameters Type Name Description Int32 idx Int32 comboCounter Int32 comboColourIdx OsuParsers.Beatmaps.Objects.Slider slider OsuParsers.Beatmaps.Beatmap beatmap Returns Type Description (T1, T2) < String , Slider > Overrides HitObjectSet.GetSliderPrefab(Int32, Int32, Int32, Slider, Beatmap)"
  },
  "api/MouseDance.Demo.MainMenu.html": {
    "href": "api/MouseDance.Demo.MainMenu.html",
    "title": "Class MainMenu | MouseDance User Docs",
    "keywords": "Class MainMenu Inheritance Object Object Component Behaviour MonoBehaviour MainMenu Namespace : MouseDance.Demo Assembly : MouseDance.Demo.dll Syntax public class MainMenu : MonoBehaviour Methods OnPressedStart() Declaration public void OnPressedStart() ShowSceneInfo(Int32) Declaration public void ShowSceneInfo(int index) Parameters Type Name Description Int32 index Extension Methods Util.SetLayerDeep(Component, LayerMask) Util.SetLayerDeep(Component, Int32) Util.SetLayerDeep(Component, LayerMask, Stack<Transform>)"
  },
  "api/MouseDance.Demo.MyHitObjectSet.html": {
    "href": "api/MouseDance.Demo.MyHitObjectSet.html",
    "title": "Class MyHitObjectSet | MouseDance User Docs",
    "keywords": "Class MyHitObjectSet Sample sub-class of HitObjectSet to show how you can change prefab instantiation rules. Inheritance Object Object ScriptableObject HitObjectSet MyHitObjectSet Inherited Members HitObjectSet.HitCirclePrefab HitObjectSet.SliderPrefab HitObjectSet.SliderTickPrefab HitObjectSet.SliderBallPrefab HitObjectSet.SdfCurvePrefab HitObjectSet.GetSliderPrefab(Int32, Int32, Int32, Slider, Beatmap) HitObjectSet.GetSliderBallPrefab(String) Namespace : MouseDance.Demo Assembly : MouseDance.Demo.dll Syntax [CreateAssetMenu(fileName = \"MyHitObjectSet\", menuName = \"MouseDance/MyHitObjectSet\")] public class MyHitObjectSet : HitObjectSet Fields SpecialHitCirclePrefab Declaration public HitCircle SpecialHitCirclePrefab Field Value Type Description HitCircle Methods GetHitCirclePrefab(Int32, Int32, Int32, HitCircle, Beatmap) Declaration public override (string, HitCircle) GetHitCirclePrefab(int idx, int comboCounter, int comboColourIdx, HitCircle hitCircle, Beatmap beatmap) Parameters Type Name Description Int32 idx Int32 comboCounter Int32 comboColourIdx OsuParsers.Beatmaps.Objects.HitCircle hitCircle OsuParsers.Beatmaps.Beatmap beatmap Returns Type Description (T1, T2) < String , HitCircle > Overrides HitObjectSet.GetHitCirclePrefab(Int32, Int32, Int32, HitCircle, Beatmap)"
  },
  "api/MouseDance.Demo.OptionsDisplay.html": {
    "href": "api/MouseDance.Demo.OptionsDisplay.html",
    "title": "Class OptionsDisplay | MouseDance User Docs",
    "keywords": "Class OptionsDisplay Handles showing/hiding an Options window, also handles user-input on the buttons of the Options window. Inheritance Object Object Component Behaviour MonoBehaviour OptionsDisplay Namespace : MouseDance.Demo Assembly : MouseDance.Demo.dll Syntax public class OptionsDisplay : MonoBehaviour Methods OnPressedBackToMenu() Called when user presses the \"Back to Menu\" button inside the Options window. Declaration public void OnPressedBackToMenu() OnPressedClose() Called when user presses the X close button. This will unpause the game while also closing the Options Window. Declaration public void OnPressedClose() OnPressedGraphicsHighButton(Boolean) Declaration public void OnPressedGraphicsHighButton(bool selected) Parameters Type Name Description Boolean selected OnPressedGraphicsLowButton(Boolean) Declaration public void OnPressedGraphicsLowButton(bool selected) Parameters Type Name Description Boolean selected OnPressedGraphicsMidButton(Boolean) Declaration public void OnPressedGraphicsMidButton(bool selected) Parameters Type Name Description Boolean selected OnPressedRestart() Called when user presses the Restart button inside the Options window. Declaration public void OnPressedRestart() OnPressedStart() Called when user presses the Start button. Declaration public void OnPressedStart() SetQualityLevelFromSavedSetting() Declaration public static void SetQualityLevelFromSavedSetting() Show() Called when user presses the pause button in the UI. This effectively pauses the game while also showing the Options Window. Declaration public void Show() Extension Methods Util.SetLayerDeep(Component, LayerMask) Util.SetLayerDeep(Component, Int32) Util.SetLayerDeep(Component, LayerMask, Stack<Transform>)"
  },
  "api/MouseDance.Demo.ResultsDisplay.html": {
    "href": "api/MouseDance.Demo.ResultsDisplay.html",
    "title": "Class ResultsDisplay | MouseDance User Docs",
    "keywords": "Class ResultsDisplay Handles showing a screen that displays player score at the end of the game. Inheritance Object Object Component Behaviour MonoBehaviour ResultsDisplay Namespace : MouseDance.Demo Assembly : MouseDance.Demo.dll Syntax public class ResultsDisplay : MonoBehaviour Methods Hide() Declaration public void Hide() Show(IBeatmapResults) Declaration public void Show(IBeatmapResults results) Parameters Type Name Description IBeatmapResults results Extension Methods Util.SetLayerDeep(Component, LayerMask) Util.SetLayerDeep(Component, Int32) Util.SetLayerDeep(Component, LayerMask, Stack<Transform>)"
  },
  "api/MouseDance.Demo.SceneButton.html": {
    "href": "api/MouseDance.Demo.SceneButton.html",
    "title": "Class SceneButton | MouseDance User Docs",
    "keywords": "Class SceneButton Inheritance Object Object Component Behaviour MonoBehaviour SceneButton Namespace : MouseDance.Demo Assembly : MouseDance.Demo.dll Syntax public class SceneButton : MonoBehaviour Methods OnPressed() Declaration public void OnPressed() Set(Int32, SceneList.Entry, MainMenu) Declaration public void Set(int idx, SceneList.Entry entry, MainMenu mainMenu) Parameters Type Name Description Int32 idx SceneList.Entry entry MainMenu mainMenu Extension Methods Util.SetLayerDeep(Component, LayerMask) Util.SetLayerDeep(Component, Int32) Util.SetLayerDeep(Component, LayerMask, Stack<Transform>)"
  },
  "api/MouseDance.Demo.SceneList.Entry.html": {
    "href": "api/MouseDance.Demo.SceneList.Entry.html",
    "title": "Class SceneList.Entry | MouseDance User Docs",
    "keywords": "Class SceneList.Entry Inheritance Object SceneList.Entry Namespace : MouseDance.Demo Assembly : MouseDance.Demo.dll Syntax [Serializable] public class Entry Fields Description Declaration [TextArea(1, 20)] public string Description Field Value Type Description String Enable Declaration public bool Enable Field Value Type Description Boolean IndentLevel Declaration public int IndentLevel Field Value Type Description Int32 Label Declaration public string Label Field Value Type Description String SceneName Declaration public string SceneName Field Value Type Description String Screenshot Declaration public Sprite Screenshot Field Value Type Description Sprite"
  },
  "api/MouseDance.Demo.SceneList.html": {
    "href": "api/MouseDance.Demo.SceneList.html",
    "title": "Class SceneList | MouseDance User Docs",
    "keywords": "Class SceneList Inheritance Object Object ScriptableObject SceneList Namespace : MouseDance.Demo Assembly : MouseDance.Demo.dll Syntax [CreateAssetMenu(fileName = \"SceneList\", menuName = \"MouseDance/SceneList\")] public class SceneList : ScriptableObject Fields DEMO_SCENE_PATH Declaration public const string DEMO_SCENE_PATH = \"Assets/MouseDance/Demo/Scenes\" Field Value Type Description String Entries Declaration public List<SceneList.Entry> Entries Field Value Type Description List < SceneList.Entry > ExcludeScenes Declaration public List<string> ExcludeScenes Field Value Type Description List < String > MAIN_MENU_SCENE_NAME Declaration public const string MAIN_MENU_SCENE_NAME = \"00-Main Menu\" Field Value Type Description String"
  },
  "api/MouseDance.Demo.SliderTest.html": {
    "href": "api/MouseDance.Demo.SliderTest.html",
    "title": "Class SliderTest | MouseDance User Docs",
    "keywords": "Class SliderTest Hardcoded tests to show some SDF curves Inheritance Object Object Component Behaviour MonoBehaviour SliderTest Namespace : MouseDance.Demo Assembly : MouseDance.Demo.dll Syntax public class SliderTest : MonoBehaviour Methods Test() Declaration public void Test() Extension Methods Util.SetLayerDeep(Component, LayerMask) Util.SetLayerDeep(Component, Int32) Util.SetLayerDeep(Component, LayerMask, Stack<Transform>)"
  },
  "api/MouseDance.Demo.Squares.html": {
    "href": "api/MouseDance.Demo.Squares.html",
    "title": "Class Squares | MouseDance User Docs",
    "keywords": "Class Squares Renders many squares on-screen meant for EQ display, using Unity UI. Inheritance Object Object Component Behaviour MonoBehaviour UnityEngine.EventSystems.UIBehaviour UnityEngine.UI.Graphic UnityEngine.UI.MaskableGraphic UnityEngine.UI.Image Squares Namespace : MouseDance.Demo Assembly : MouseDance.Demo.dll Syntax public class Squares : Image, ICanvasElement, IClippable, IMaskable, IMaterialModifier, ISerializationCallbackReceiver, ILayoutElement, ICanvasRaycastFilter Methods Clear() Declaration public void Clear() OnPopulateMesh(VertexHelper) Declaration protected override void OnPopulateMesh(VertexHelper vh) Parameters Type Name Description UnityEngine.UI.VertexHelper vh Overrides UnityEngine.UI.Image.OnPopulateMesh(UnityEngine.UI.VertexHelper) SetRows(Int32, Int32) Declaration public void SetRows(int columnIdx, int numberOfRows) Parameters Type Name Description Int32 columnIdx Int32 numberOfRows SetRowsNoDirty(Int32, Int32) Declaration public void SetRowsNoDirty(int columnIdx, int numberOfRows) Parameters Type Name Description Int32 columnIdx Int32 numberOfRows Start() Declaration protected override void Start() Overrides UnityEngine.EventSystems.UIBehaviour.Start() Extension Methods Util.SetLayerDeep(Component, LayerMask) Util.SetLayerDeep(Component, Int32) Util.SetLayerDeep(Component, LayerMask, Stack<Transform>) GraphicsUtil.SetAlpha(Graphic, Single)"
  },
  "api/MouseDance.Demo.TestSDF2Line.html": {
    "href": "api/MouseDance.Demo.TestSDF2Line.html",
    "title": "Class TestSDF2Line | MouseDance User Docs",
    "keywords": "Class TestSDF2Line Inheritance Object Object Component Behaviour MonoBehaviour TestSDF2Line Namespace : MouseDance.Demo Assembly : MouseDance.Demo.dll Syntax [ExecuteInEditMode] public class TestSDF2Line : MonoBehaviour Methods Test() Declaration public void Test() Extension Methods Util.SetLayerDeep(Component, LayerMask) Util.SetLayerDeep(Component, Int32) Util.SetLayerDeep(Component, LayerMask, Stack<Transform>)"
  },
  "api/MouseDance.Demo.TestSDF3Line.html": {
    "href": "api/MouseDance.Demo.TestSDF3Line.html",
    "title": "Class TestSDF3Line | MouseDance User Docs",
    "keywords": "Class TestSDF3Line Inheritance Object Object Component Behaviour MonoBehaviour TestSDF3Line Namespace : MouseDance.Demo Assembly : MouseDance.Demo.dll Syntax [ExecuteInEditMode] public class TestSDF3Line : MonoBehaviour Methods Test() Declaration public void Test() Extension Methods Util.SetLayerDeep(Component, LayerMask) Util.SetLayerDeep(Component, Int32) Util.SetLayerDeep(Component, LayerMask, Stack<Transform>)"
  },
  "api/MouseDance.Demo.TestSDFCurve.html": {
    "href": "api/MouseDance.Demo.TestSDFCurve.html",
    "title": "Class TestSDFCurve | MouseDance User Docs",
    "keywords": "Class TestSDFCurve Inheritance Object Object Component Behaviour MonoBehaviour TestSDFCurve Namespace : MouseDance.Demo Assembly : MouseDance.Demo.dll Syntax [ExecuteInEditMode] public class TestSDFCurve : MonoBehaviour Methods Reposition() Declaration public void Reposition() Test() Declaration public void Test() Extension Methods Util.SetLayerDeep(Component, LayerMask) Util.SetLayerDeep(Component, Int32) Util.SetLayerDeep(Component, LayerMask, Stack<Transform>)"
  },
  "api/MouseDance.Demo.TestSDFLine.html": {
    "href": "api/MouseDance.Demo.TestSDFLine.html",
    "title": "Class TestSDFLine | MouseDance User Docs",
    "keywords": "Class TestSDFLine Inheritance Object Object Component Behaviour MonoBehaviour TestSDFLine Namespace : MouseDance.Demo Assembly : MouseDance.Demo.dll Syntax [ExecuteInEditMode] public class TestSDFLine : MonoBehaviour Methods Test() Declaration public void Test() Extension Methods Util.SetLayerDeep(Component, LayerMask) Util.SetLayerDeep(Component, Int32) Util.SetLayerDeep(Component, LayerMask, Stack<Transform>)"
  },
  "api/MouseDance.Editor.BeatmapRunnerEditor.html": {
    "href": "api/MouseDance.Editor.BeatmapRunnerEditor.html",
    "title": "Class BeatmapRunnerEditor | MouseDance User Docs",
    "keywords": "Class BeatmapRunnerEditor Provides debug and diagnostic info on top of the Inspector for BeatmapRunner . Inheritance Object Object ScriptableObject Editor BeatmapRunnerEditor Namespace : MouseDance.Editor Assembly : MouseDance.Editor.dll Syntax [CustomEditor(typeof(BeatmapRunner))] public class BeatmapRunnerEditor : Editor Methods OnInspectorGUI() Declaration public override void OnInspectorGUI() Overrides Editor.OnInspectorGUI()"
  },
  "api/MouseDance.Editor.HitCircleEditor.html": {
    "href": "api/MouseDance.Editor.HitCircleEditor.html",
    "title": "Class HitCircleEditor | MouseDance User Docs",
    "keywords": "Class HitCircleEditor Provides buttons to preview the Hit Circle in different Circle Size settings on top of the Inspector for HitCircle . Inheritance Object Object ScriptableObject Editor HitCircleEditor Namespace : MouseDance.Editor Assembly : MouseDance.Editor.dll Syntax [CustomEditor(typeof(HitCircle))] public class HitCircleEditor : Editor Methods OnInspectorGUI() Declaration public override void OnInspectorGUI() Overrides Editor.OnInspectorGUI()"
  },
  "api/MouseDance.Editor.HitObjectColoursEditor.html": {
    "href": "api/MouseDance.Editor.HitObjectColoursEditor.html",
    "title": "Class HitObjectColoursEditor | MouseDance User Docs",
    "keywords": "Class HitObjectColoursEditor Provides easier controls for editing colours of a HitObjectColours . Inheritance Object Object ScriptableObject Editor HitObjectColoursEditor Namespace : MouseDance.Editor Assembly : MouseDance.Editor.dll Syntax [CustomEditor(typeof(HitObjectColours))] public class HitObjectColoursEditor : Editor Methods OnInspectorGUI() Declaration public override void OnInspectorGUI() Overrides Editor.OnInspectorGUI()"
  },
  "api/MouseDance.Editor.HitObjectSetEditor.html": {
    "href": "api/MouseDance.Editor.HitObjectSetEditor.html",
    "title": "Class HitObjectSetEditor | MouseDance User Docs",
    "keywords": "Class HitObjectSetEditor Provides copy-paste functionality for HitObjectSet and its sub-classes. Inheritance Object Object ScriptableObject Editor HitObjectSetEditor Namespace : MouseDance.Editor Assembly : MouseDance.Editor.dll Syntax [CustomEditor(typeof(HitObjectSet), true)] public class HitObjectSetEditor : Editor Remarks This allows copying values from an asset of type base class HitObjectSet , and pasting them onto an asset that is a HitObjectSet sub-class, and vice-versa. Methods OnInspectorGUI() Declaration public override void OnInspectorGUI() Overrides Editor.OnInspectorGUI()"
  },
  "api/MouseDance.Editor.html": {
    "href": "api/MouseDance.Editor.html",
    "title": "Namespace MouseDance.Editor | MouseDance User Docs",
    "keywords": "Namespace MouseDance.Editor Editor scripts that MouseDance uses. Only used in the Unity Editor. Classes BeatmapRunnerEditor Provides debug and diagnostic info on top of the Inspector for BeatmapRunner . HitCircleEditor Provides buttons to preview the Hit Circle in different Circle Size settings on top of the Inspector for HitCircle . HitObjectColoursEditor Provides easier controls for editing colours of a HitObjectColours . HitObjectSetEditor Provides copy-paste functionality for HitObjectSet and its sub-classes. OsuFileImporter Allows .osu files in a Unity Project to be recognized as TextAsset files. Util Minor reused variables for custom Inspectors."
  },
  "api/MouseDance.Editor.OsuFileImporter.html": {
    "href": "api/MouseDance.Editor.OsuFileImporter.html",
    "title": "Class OsuFileImporter | MouseDance User Docs",
    "keywords": "Class OsuFileImporter Allows .osu files in a Unity Project to be recognized as TextAsset files. Inheritance Object Object AssetImporter UnityEditor.AssetImporters.ScriptedImporter OsuFileImporter Namespace : MouseDance.Editor Assembly : MouseDance.Editor.dll Syntax [ScriptedImporter(1, \"osu\")] public class OsuFileImporter : ScriptedImporter Methods OnImportAsset(AssetImportContext) Declaration public override void OnImportAsset(AssetImportContext ctx) Parameters Type Name Description UnityEditor.AssetImporters.AssetImportContext ctx Overrides UnityEditor.AssetImporters.ScriptedImporter.OnImportAsset(UnityEditor.AssetImporters.AssetImportContext)"
  },
  "api/MouseDance.Editor.Util.html": {
    "href": "api/MouseDance.Editor.Util.html",
    "title": "Class Util | MouseDance User Docs",
    "keywords": "Class Util Minor reused variables for custom Inspectors. Inheritance Object Util Namespace : MouseDance.Editor Assembly : MouseDance.Editor.dll Syntax public static class Util Fields Height30 Declaration public static readonly GUILayoutOption[] Height30 Field Value Type Description GUILayoutOption [] NoExpandWidth Declaration public static readonly GUILayoutOption[] NoExpandWidth Field Value Type Description GUILayoutOption []"
  },
  "api/MouseDance.Runtime.BeatmapAreaAdjuster.html": {
    "href": "api/MouseDance.Runtime.BeatmapAreaAdjuster.html",
    "title": "Class BeatmapAreaAdjuster | MouseDance User Docs",
    "keywords": "Class BeatmapAreaAdjuster Adds an optional position offset to the 4:3 area of the Beatmap, especially meant for use in portrait mode (i.e. mobile). Inheritance Object Object Component Behaviour MonoBehaviour BeatmapAreaAdjuster Namespace : MouseDance.Runtime Assembly : MouseDance.Runtime.dll Syntax public class BeatmapAreaAdjuster : MonoBehaviour Remarks Beatmaps are positioned only in a 4:3 area that is automatically resized to fit on screen, centered. But during portrait mode, you may want to anchor the area closer to the bottom or to the top, depending on your game. That is what the BeatmapAreaAdjuster can do. This component should be attached to the UI Canvas so that it can receive OnRectTransformDimensionsChange events. Extension Methods Util.SetLayerDeep(Component, LayerMask) Util.SetLayerDeep(Component, Int32) Util.SetLayerDeep(Component, LayerMask, Stack<Transform>)"
  },
  "api/MouseDance.Runtime.BeatmapRunner.html": {
    "href": "api/MouseDance.Runtime.BeatmapRunner.html",
    "title": "Class BeatmapRunner | MouseDance User Docs",
    "keywords": "Class BeatmapRunner Main class for starting a beatmap. Inheritance Object Object Component Behaviour MonoBehaviour BeatmapRunner Implements IBeatmapRunner IBeatmapResults Namespace : MouseDance.Runtime Assembly : MouseDance.Runtime.dll Syntax public class BeatmapRunner : MonoBehaviour, IBeatmapRunner, IBeatmapResults Remarks Runs a beatmap given the osu file and/or audio clip, keeps track of song's current time to figure out when new Hit Objects should be spawned, detects user-input to see if player hit a Hit Object, and keeps track of all Hit Objects that player was able to hit. Properties CanPressNow Is the user allowed to press hit objects right now? Returns false if the game hasn't started yet, or if the game has already finished. Declaration public bool CanPressNow { get; } Property Value Type Description Boolean GetBeatmapEndType If we have a IBeatmapEnd callback registered, this is its type. Declaration public Type GetBeatmapEndType { get; } Property Value Type Description Type GetBeatmapInputType If we have a IBeatmapInput callback registered, this is its type. Declaration public Type GetBeatmapInputType { get; } Property Value Type Description Type GetBeatmapLoadedType If we have a IBeatmapLoaded callback registered, this is its type. Declaration public Type GetBeatmapLoadedType { get; } Property Value Type Description Type GetClickedHitObjectType If we have a IClickedHitObject callback registered, this is its type. Declaration public Type GetClickedHitObjectType { get; } Property Value Type Description Type GetCustomCollectRuleType If we have a ICustomCollectRule callback registered, this is its type. Declaration public Type GetCustomCollectRuleType { get; } Property Value Type Description Type GetHitObjectSizeCalculatorType If we have a IHitObjectSizeCalculator callback registered, this is its type. Declaration public Type GetHitObjectSizeCalculatorType { get; } Property Value Type Description Type GetScoreCalculatorType If we have a IBeatmapScoreCalculator callback registered, this is its type. Declaration public Type GetScoreCalculatorType { get; } Property Value Type Description Type GetSongStartCountdownType If we have a ISongStartCountdown callback registered, this is its type. Declaration public Type GetSongStartCountdownType { get; } Property Value Type Description Type HasBeatmapEnd Whether we have a IBeatmapEnd callback registered. Declaration public bool HasBeatmapEnd { get; } Property Value Type Description Boolean HasBeatmapLoadedCallback Whether we have a IBeatmapLoaded callback registered. Declaration public bool HasBeatmapLoadedCallback { get; } Property Value Type Description Boolean HasClickedHitObject Whether we have a IClickedHitObject callback registered. Declaration public bool HasClickedHitObject { get; } Property Value Type Description Boolean HasCustomCollectRule Whether we have a ICustomCollectRule callback registered. Declaration public bool HasCustomCollectRule { get; } Property Value Type Description Boolean HasHitObjectSizeCalculator Whether we have a IHitObjectSizeCalculator callback registered. Declaration public bool HasHitObjectSizeCalculator { get; } Property Value Type Description Boolean HasInput Whether we have a IBeatmapInput callback registered. Declaration public bool HasInput { get; } Property Value Type Description Boolean HasScoreCalculator Whether we have a IBeatmapScoreCalculator callback registered. Declaration public bool HasScoreCalculator { get; } Property Value Type Description Boolean HasSongStartCountdown Whether we have a ISongStartCountdown callback registered. Declaration public bool HasSongStartCountdown { get; } Property Value Type Description Boolean HitObjects Read-only list of all hit objects used in the song's beatmap. Declaration public IReadOnlyList<HitObject> HitObjects { get; } Property Value Type Description IReadOnlyList < OsuParsers.Beatmaps.Objects.HitObject > PlayerWin Did the player win? Declaration public bool PlayerWin { get; } Property Value Type Description Boolean Score Player's current score. Declaration public long Score { get; } Property Value Type Description Int64 SongEnded Whether it's time to display results or not. Declaration public bool SongEnded { get; } Property Value Type Description Boolean SongProgress 0.0 to 1.0 value range of the currently played song's progress. Declaration public float SongProgress { get; } Property Value Type Description Single Methods CanCollectSliderPart(IHitObject) Called by Slider to check if we can proceed with collecting a Slider part. Declaration public bool CanCollectSliderPart(IHitObject slider) Parameters Type Name Description IHitObject slider Returns Type Description Boolean True if we allow the Slider to collect the Slider part. Remarks This uses any registered ICustomCollectRule callback to check if player is allowed to collect the Slider part using AllowCollectSliderPart(IHitObject) . GetHitAccuracy(Int32) How close to the Hit Object's time did the player get when they pressed on a Hit Object. Declaration public float GetHitAccuracy(int hitObjectIdx) Parameters Type Name Description Int32 hitObjectIdx Index of the Hit Object we are checking. Returns Type Description Single Normalized value indicating if user pressed Hit Object within correct time window. -1.0 to +1.0 is a hit. Any value outside that (lesser than -1.0 or greater than +1.0) means miss (negative for too early, positive for too late). 0.0 means user pressed exactly at Hit Object time. GetSliderPercentComplete(Int32) Get how much slider parts did the player collect for the specified slider, in percent. Declaration public float GetSliderPercentComplete(int sliderIdx) Parameters Type Name Description Int32 sliderIdx Returns Type Description Single Value within 0.0 to 1.0. 1.0 means 100% all collected. 0.5 means 50%, etc. -1 if the Slider was missed or if index specified is not for a Slider at all. LoadAndStart(Beatmap, AudioClip) Use of the specified Beatmap, and the song from the AudioClip specified (the AudioFilename specified in the osu file is ignored), then start playing. Use this if you already have a Beatmap loaded/generated somewhere else. Declaration public void LoadAndStart(Beatmap beatmap, AudioClip song) Parameters Type Name Description OsuParsers.Beatmaps.Beatmap beatmap Beatmap that you want to be used. AudioClip song Song that you want to be played. This overrides the AudioFilename specified in the osu file. LoadAndStart(String) Load the .osu file specified, and the song indicated inside it (AudioFilename property), then start playing. Declaration public void LoadAndStart(string osuFilePath) Parameters Type Name Description String osuFilePath Full path to the osu file you want to load. LoadAndStart(String, AudioClip) Load the .osu file specified, and the song from the AudioClip specified (the AudioFilename specified in the osu file is ignored), then start playing. Declaration public void LoadAndStart(string osuFilePath, AudioClip song) Parameters Type Name Description String osuFilePath Full path to the osu file you want to load. AudioClip song Song that you want to be played. This overrides the AudioFilename specified in the osu file. LoadAndStart(TextAsset, AudioClip) Load the .osu data from the TextAsset specified, and the song from the AudioClip specified (the AudioFilename specified in the osu file is ignored), then start playing. Declaration public void LoadAndStart(TextAsset osuFile, AudioClip song) Parameters Type Name Description TextAsset osuFile Osu file that you want to load. AudioClip song Song that you want to be played. This overrides the AudioFilename specified in the osu file. OnUserFinishedSlider(IHitObjectWithEvents, Int32, Int32, Int32, Boolean) Called by OnReachedEnd() to let the BeatmapRunner know that user has their mouse down on the Slider as it finished, so that it can calculate the score that the player gets for this Slider and tally it. Declaration public void OnUserFinishedSlider(IHitObjectWithEvents slider, int headScore, int collected, int total, bool pressWasEverReleased) Parameters Type Name Description IHitObjectWithEvents slider Slider that was finished. Int32 headScore What score the player got when they pressed on the Slider's head. Int32 collected How many parts of the Slider was collected (head, ticks, tail, repeats). Int32 total Total number of parts the Slider has (head, ticks, tail, repeats). Boolean pressWasEverReleased Even if player has their mouse down right now, did player ever release their press of the button throughout the Slider? OnUserPressedHitCircle(IHitObjectWithEvents) Called by OnPressed(Int32) to let BeatmapRunner know that the user pressed on the HitCircle so it can tally and add to the score. Simultaneously, this also lets the Hit Circle know if user pressed within correct time window and how much score was received for it. Declaration public (float, int) OnUserPressedHitCircle(IHitObjectWithEvents hitCircle) Parameters Type Name Description IHitObjectWithEvents hitCircle Hit Circle that was pressed. Returns Type Description (T1, T2) < Single , Int32 > Single: Normalized value indicating if user pressed within correct time window. -1.0 to +1.0 is a hit. Any value outside that (lesser than -1.0 or greater than +1.0) means miss (negative for too early, positive for too late). 0.0 means user pressed exactly at hit circle's time. int: score given for this particular pressed hit circle OnUserPressedSliderHead(Int32) Called by OnPressed(Int32) when user pressed the head (aka Start Cap) of a Slider. This is used to let the Slider know if user pressed within the correct time window, and what the equivalent score would be for that head press. Declaration public (float, int) OnUserPressedSliderHead(int idx) Parameters Type Name Description Int32 idx Index of the Slider that was pressed. Returns Type Description (T1, T2) < Single , Int32 > Single: Normalized value indicating if user pressed slider's head within correct time window. -1.0 to +1.0 is a hit. Any value outside that (lesser than -1.0 or greater than +1.0) means miss (negative for too early, positive for too late). 0.0 means user pressed exactly at slider head's hit time. int: Equivalent score for pressing the Slider head. The score value here is not added to the player's score, but is calculated to let you know if the user did a perfect press or not. Pause(Boolean) Stop the Beatmap Runner from processing. That means the song will be paused, no hit objects will be spawned, and user-input is not checked. Declaration public void Pause(bool pause) Parameters Type Name Description Boolean pause RecalculateDisplayedHitObjectSize() Recalculate the size of currently displayed Hit Objects. Declaration public void RecalculateDisplayedHitObjectSize() Restart() Play current song and beatmap again from the beginning. This assumes a song has already been loaded via LoadAndStart(String) or LoadAndStart(TextAsset, AudioClip) Declaration public void Restart() SetBeatmapEnd(IBeatmapEnd) Assign what receives the callback event when the game ends. See IBeatmapEnd . Declaration public void SetBeatmapEnd(IBeatmapEnd newBeatmapEnd) Parameters Type Name Description IBeatmapEnd newBeatmapEnd The object that will receive the notification that the game has ended. Use null if you no longer want BeatmapRunner from sending this notification. SetCustomCollectRule(ICustomCollectRule) Assign what calculates any custom rule regarding hit object collection. See ICustomCollectRule . Call this before starting the beatmap. Declaration public void SetCustomCollectRule(ICustomCollectRule newCustomCollectRule) Parameters Type Name Description ICustomCollectRule newCustomCollectRule The object that will add any custom rules. SetHitObjectSizeCalculator(IHitObjectSizeCalculator) Assign what calculates hit object size. See IHitObjectSizeCalculator . Call this before starting the beatmap. Declaration public void SetHitObjectSizeCalculator(IHitObjectSizeCalculator newHitObjectSizeCalculator) Parameters Type Name Description IHitObjectSizeCalculator newHitObjectSizeCalculator The object that calculates hit object size. SetInput(IBeatmapInput) Assign what dictates whether user-input has been pressed or not. See IBeatmapInput . Call this before starting the beatmap. Declaration public void SetInput(IBeatmapInput newInput) Parameters Type Name Description IBeatmapInput newInput The object that will dictate whether user-input has been pressed or not. Set to null if you want BeatmapRunner to go back to using defaults. SetOnBeatmapLoaded(IBeatmapLoaded) Set the object that you want to be notified of the event when a Beatmap has been loaded (with LoadAndStart) but right before the game is actually started. See IBeatmapLoaded . This event can be used to edit the beatmap as much as you want before it is used. Declaration public void SetOnBeatmapLoaded(IBeatmapLoaded newBeatmapLoaded) Parameters Type Name Description IBeatmapLoaded newBeatmapLoaded The object that will receive the OnBeatmapLoaded notification. Use null if you no longer want the BeatmapRunner to send the notification. SetOnClickedHitObject(IClickedHitObject) Assign what receives the callback event when player clicks on a Hit Object, whether hit or miss. See IClickedHitObject . Call this before starting the beatmap. Declaration public void SetOnClickedHitObject(IClickedHitObject newClickedHitObject) Parameters Type Name Description IClickedHitObject newClickedHitObject The object that will receive the event. SetScoreCalculator(IBeatmapScoreCalculator) Assign what calculates the score that the player will get for hitting a Hit Object. See IBeatmapScoreCalculator . Call this before starting the beatmap. Declaration public void SetScoreCalculator(IBeatmapScoreCalculator newScoreCalculator) Parameters Type Name Description IBeatmapScoreCalculator newScoreCalculator The object that will calculate the score. SetSongStartCountdown(ISongStartCountdown) Assign what receives the callback event when countdown animation should begin. See ISongStartCountdown . Call this right before starting the beatmap. Declaration public void SetSongStartCountdown(ISongStartCountdown newStartCountdown) Parameters Type Name Description ISongStartCountdown newStartCountdown The object that receives the event when countdown animation should begin. Set to null if you no longer want BeatmapRunner to send this event. WasHit(Int32) Did the player successfully press the hit object with the specified index? Index value corresponds to the list in HitObjects . Declaration public bool WasHit(int hitObjectIdx) Parameters Type Name Description Int32 hitObjectIdx Returns Type Description Boolean Implements IBeatmapRunner IBeatmapResults Extension Methods Util.SetLayerDeep(Component, LayerMask) Util.SetLayerDeep(Component, Int32) Util.SetLayerDeep(Component, LayerMask, Stack<Transform>)"
  },
  "api/MouseDance.Runtime.BeatmapUtil.html": {
    "href": "api/MouseDance.Runtime.BeatmapUtil.html",
    "title": "Class BeatmapUtil | MouseDance User Docs",
    "keywords": "Class BeatmapUtil Utility code for getting/deriving Beatmap properties. Inheritance Object BeatmapUtil Namespace : MouseDance.Runtime Assembly : MouseDance.Runtime.dll Syntax public static class BeatmapUtil Fields MEDIUM_HIT_SCORE Amount of score given if the player pressed a hit object within the 100 score hit-window. Declaration public const int MEDIUM_HIT_SCORE = 100 Field Value Type Description Int32 PERFECT_HIT_SCORE Amount of score given if the player pressed a hit object within the 300 score hit-window. Declaration public const int PERFECT_HIT_SCORE = 300 Field Value Type Description Int32 SMALLEST_HIT_SCORE Amount of score given if the player pressed a hit object within the 50 score hit-window. Declaration public const int SMALLEST_HIT_SCORE = 50 Field Value Type Description Int32 Methods DebugLog(Beatmap) Outputs properties of the Beatmap into the Unity console window. Use this for a quick test to see if your .osu file loaded correctly. Declaration public static void DebugLog(this Beatmap beatmap) Parameters Type Name Description OsuParsers.Beatmaps.Beatmap beatmap Beatmap that you want to Debug Log GetCircleRadius(Single) Get Radius of Hit Circles and Sliders given the Beatmap's Circle Size. Declaration public static float GetCircleRadius(float circleSize) Parameters Type Name Description Single circleSize 0 to 10 value range Returns Type Description Single Radius, in osu!pixels . Remarks See official docs for Circle size . Higher Circle Size means smaller radius. Circle Size Radius in osu!pixels 0 54.4 1 49.92 2 45.44 (largest allowed in the osu editor) 3 40.96 4 36.48 5 32 (default) 6 27.52 7 23.04 (smallest allowed in the osu editor) 8 18.56 9 14.08 10 9.6 GetFadeInDuration(Beatmap) For hit objects, this is the amount of time (in milliseconds) it fades in. After this duration, the hit object should be showing at 100% opacity. Formula comes from official docs on Approach rate . Declaration public static float GetFadeInDuration(this Beatmap beatmap) Parameters Type Name Description OsuParsers.Beatmaps.Beatmap beatmap Returns Type Description Single Remarks X = hit/collect p r e e m p t   0% FADE IN 100% opacity GetFullOpacityDuration(Beatmap) For hit objects, this is the amount of time (in milliseconds) the hit object stays at 100% opacity. Formula comes from official docs on Approach rate . Declaration public static float GetFullOpacityDuration(this Beatmap beatmap) Parameters Type Name Description OsuParsers.Beatmaps.Beatmap beatmap Returns Type Description Single Remarks X = hit/collect p r e e m p t   0% fade_in 100% opacity GetHitWindows(Beatmap) Time windows (in milliseconds) for getting score 50, 100, and 300 score. Higher scores have shorter time windows. This is affected by the Beatmap's Overall difficulty . Declaration public static (float, float, float) GetHitWindows(this Beatmap beatmap) Parameters Type Name Description OsuParsers.Beatmaps.Beatmap beatmap Beatmap to get the Overall difficulty from. Returns Type Description (T1, T2, T3) < Single , Single , Single > The time windows (in milliseconds) for getting each score, 50, 100, 300, respectively. Remarks See official docs on Overall difficulty . GetPreemptDuration(Beatmap) For hit objects, this is the total duration (in milliseconds) that it appears, starting from the time it fades in, until it is time to hit it. Formula comes from official docs on Approach rate . Declaration public static float GetPreemptDuration(this Beatmap beatmap) Parameters Type Name Description OsuParsers.Beatmaps.Beatmap beatmap Returns Type Description Single Remarks X = hit/collect P R E E M P T   0% fade_in 100% opacity GetPreemptDuration(Single) For hit objects, this is the total duration (in milliseconds) that it appears, starting from the time it fades in, until it is time to hit it. Formula comes from official docs on Approach rate . Declaration public static float GetPreemptDuration(float approachRate) Parameters Type Name Description Single approachRate Returns Type Description Single Remarks X = hit/collect P R E E M P T   0% fade_in 100% opacity GetSliderBaseScore(Int32, Int32) Out of the percent of pressed vs total, this will return SMALLEST_HIT_SCORE , MEDIUM_HIT_SCORE , or PERFECT_HIT_SCORE . Declaration public static int GetSliderBaseScore(int collected, int total) Parameters Type Name Description Int32 collected Int32 total Returns Type Description Int32 Remarks Percent of collected vs total Return value 0 0 >0 to 1/3 (>0 to 33%) SMALLEST_HIT_SCORE 1/3 to 2/3 (33% to 66%) MEDIUM_HIT_SCORE 2/3 to 3/3 (66% to 100%) PERFECT_HIT_SCORE"
  },
  "api/MouseDance.Runtime.Callbacks.html": {
    "href": "api/MouseDance.Runtime.Callbacks.html",
    "title": "Namespace MouseDance.Runtime.Callbacks | MouseDance User Docs",
    "keywords": "Namespace MouseDance.Runtime.Callbacks Interfaces IBeatmapEnd Implement this if you want to be notified of when the game ends. Make sure to call SetBeatmapEnd(IBeatmapEnd) before starting the game, for this to actually work. IBeatmapInput Implement this if you want to customize how BeatmapRunner checks for user-input. Remember to call SetInput(IBeatmapInput) before starting the game, for this to actually work. IBeatmapLoaded Implement this if you want to be notified when a Beatmap has been loaded by the Beatmap Runner. Make sure to call SetOnBeatmapLoaded(IBeatmapLoaded) before starting the game, for this to actually work. IBeatmapMultiInput Implement this if your game allows more than one beatmap being played simultaneously, or if you want to allow multi-touch input (in mobile). IBeatmapScoreCalculator Implement this if you want to customize how player's score is calculated per Hit Object that the player hits. Remember to call SetScoreCalculator(IBeatmapScoreCalculator) before starting the game, for this to actually work. IClickedHitObject Implement this if you want notification of event when a Hit Object is pressed/collected/missed. Remember to call SetOnClickedHitObject(IClickedHitObject) before starting the game, for this to actually work. ICustomCollectRule Implement this if you want to add custom rules on how Hit Objects are pressed. Remember to call SetCustomCollectRule(ICustomCollectRule) before starting the game, for this to actually work. IHitObjectSizeCalculator Implement this if you want to edit the size of each Hit Object just as they are about to be spawned. Make sure to call SetHitObjectSizeCalculator(IHitObjectSizeCalculator) before starting the game, for this to actually work. ISongStartCountdown Implement this if you want to be able to play your own countdown animation before the first Hit Object appears. Make sure to call SetSongStartCountdown(ISongStartCountdown) before starting the game, for this to actually work."
  },
  "api/MouseDance.Runtime.Callbacks.IBeatmapEnd.html": {
    "href": "api/MouseDance.Runtime.Callbacks.IBeatmapEnd.html",
    "title": "Interface IBeatmapEnd | MouseDance User Docs",
    "keywords": "Interface IBeatmapEnd Implement this if you want to be notified of when the game ends. Make sure to call SetBeatmapEnd(IBeatmapEnd) before starting the game, for this to actually work. Namespace : MouseDance.Runtime.Callbacks Assembly : MouseDance.Runtime.dll Syntax public interface IBeatmapEnd Methods OnBeatmapEnd(IBeatmapResults) Called when the game ends. Declaration void OnBeatmapEnd(IBeatmapResults results) Parameters Type Name Description IBeatmapResults results Info on the player's score and performance."
  },
  "api/MouseDance.Runtime.Callbacks.IBeatmapInput.html": {
    "href": "api/MouseDance.Runtime.Callbacks.IBeatmapInput.html",
    "title": "Interface IBeatmapInput | MouseDance User Docs",
    "keywords": "Interface IBeatmapInput Implement this if you want to customize how BeatmapRunner checks for user-input. Remember to call SetInput(IBeatmapInput) before starting the game, for this to actually work. Namespace : MouseDance.Runtime.Callbacks Assembly : MouseDance.Runtime.dll Syntax public interface IBeatmapInput Properties CursorPosition Called by the BeatmapRunner to get where the mouse position is. Declaration Vector2 CursorPosition { get; } Property Value Type Description Vector2 Remarks The bottom-left of the screen or window is at (0, 0). The top-right of the screen or window is at (Screen.width, Screen.height). IsPlayerInputDown Called by the BeatmapRunner to check if the user-input was just pressed this frame. Declaration bool IsPlayerInputDown { get; } Property Value Type Description Boolean Should return true during the frame that user-input became pressed. Remarks This should only return true during the frame when the button has just been pressed. This should not keep returning true while the button is held down. IsPlayerInputUp Called by the BeatmapRunner to check if user-input was just released this frame. Declaration bool IsPlayerInputUp { get; } Property Value Type Description Boolean Should return true if user-input just released the button this frame. Remarks This should only return true during the frame when the button has been released. This should not keep returning true while the button is released."
  },
  "api/MouseDance.Runtime.Callbacks.IBeatmapLoaded.html": {
    "href": "api/MouseDance.Runtime.Callbacks.IBeatmapLoaded.html",
    "title": "Interface IBeatmapLoaded | MouseDance User Docs",
    "keywords": "Interface IBeatmapLoaded Implement this if you want to be notified when a Beatmap has been loaded by the Beatmap Runner. Make sure to call SetOnBeatmapLoaded(IBeatmapLoaded) before starting the game, for this to actually work. Namespace : MouseDance.Runtime.Callbacks Assembly : MouseDance.Runtime.dll Syntax public interface IBeatmapLoaded Methods OnBeatmapLoaded(Beatmap) Called after a beatmap has been loaded (with LoadAndStart) but right before the game is actually started. This can be used to edit the beatmap as much as you want before it is used. Make sure you call SetOnBeatmapLoaded(IBeatmapLoaded) before the game is started so that this actually gets called. Declaration void OnBeatmapLoaded(Beatmap beatmap) Parameters Type Name Description OsuParsers.Beatmaps.Beatmap beatmap Editable reference to the beatmap. Remarks This is only called once for every .osu file that has just been loaded. It is not called repeatedly when the song is restarted."
  },
  "api/MouseDance.Runtime.Callbacks.IBeatmapMultiInput.html": {
    "href": "api/MouseDance.Runtime.Callbacks.IBeatmapMultiInput.html",
    "title": "Interface IBeatmapMultiInput | MouseDance User Docs",
    "keywords": "Interface IBeatmapMultiInput Implement this if your game allows more than one beatmap being played simultaneously, or if you want to allow multi-touch input (in mobile). Namespace : MouseDance.Runtime.Callbacks Assembly : MouseDance.Runtime.dll Syntax public interface IBeatmapMultiInput Properties InputCount Declaration int InputCount { get; } Property Value Type Description Int32 Methods CursorPosition(Int32) Called by the BeatmapRunner to get where the mouse position is. Declaration Vector2 CursorPosition(int inputIdx) Parameters Type Name Description Int32 inputIdx Returns Type Description Vector2 Remarks The bottom-left of the screen or window is at (0, 0). The top-right of the screen or window is at (Screen.width, Screen.height). IsPlayerInputDown(Int32) Called by the BeatmapRunner to check if the user-input was just pressed this frame. Declaration bool IsPlayerInputDown(int inputIdx) Parameters Type Name Description Int32 inputIdx Returns Type Description Boolean Should return true during the frame that user-input became pressed. Remarks This should only return true during the frame when the button has just been pressed. This should not keep returning true while the button is held down. IsPlayerInputUp(Int32) Called by the BeatmapRunner to check if user-input was just released this frame. Declaration bool IsPlayerInputUp(int inputIdx) Parameters Type Name Description Int32 inputIdx Returns Type Description Boolean Should return true if user-input just released the button this frame. Remarks This should only return true during the frame when the button has been released. This should not keep returning true while the button is released."
  },
  "api/MouseDance.Runtime.Callbacks.IBeatmapScoreCalculator.html": {
    "href": "api/MouseDance.Runtime.Callbacks.IBeatmapScoreCalculator.html",
    "title": "Interface IBeatmapScoreCalculator | MouseDance User Docs",
    "keywords": "Interface IBeatmapScoreCalculator Implement this if you want to customize how player's score is calculated per Hit Object that the player hits. Remember to call SetScoreCalculator(IBeatmapScoreCalculator) before starting the game, for this to actually work. Namespace : MouseDance.Runtime.Callbacks Assembly : MouseDance.Runtime.dll Syntax public interface IBeatmapScoreCalculator Methods CalculateScore(IHitObject, Int32, Beatmap) Calculate the score the player will get for pressing a Hit Circle. Declaration int CalculateScore(IHitObject hitCircle, int gotHitCircleValue, Beatmap beatmap) Parameters Type Name Description IHitObject hitCircle The Hit Circle that was pressed that we're calculating score for. Int32 gotHitCircleValue The 50, 100, or 300 score that the player got for pressing this Hit Circle. OsuParsers.Beatmaps.Beatmap beatmap Entire beatmap. Apart from data on all the Hit Objects, this includes difficulty properties, among other things. Returns Type Description Int32 How much is to be added to the player's score. CalculateScore(IHitObject, Int32, Int32, Int32, Boolean, Beatmap) Calculate the score the player will get for finishing a Slider. Declaration int CalculateScore(IHitObject slider, int gotSliderHeadScore, int collectedSliderParts, int totalSliderParts, bool wasPressEverReleased, Beatmap beatmap) Parameters Type Name Description IHitObject slider The Slider we're calculating score for. Int32 gotSliderHeadScore The 50, 100, or 300 score that the player got when they pressed this Slider's head. Int32 collectedSliderParts Amount of Slider parts that the player collected (head, ticks, tail, repeats). Int32 totalSliderParts Total number of parts the Slider has (head, ticks, tail, repeats). Boolean wasPressEverReleased Even if player has their mouse down right now, did player ever release their press of the button throughout the Slider? OsuParsers.Beatmaps.Beatmap beatmap Entire beatmap. Apart from data on all the Hit Objects, this includes difficulty properties, among other things. Returns Type Description Int32 How much is to be added to the player's score."
  },
  "api/MouseDance.Runtime.Callbacks.IClickedHitObject.html": {
    "href": "api/MouseDance.Runtime.Callbacks.IClickedHitObject.html",
    "title": "Interface IClickedHitObject | MouseDance User Docs",
    "keywords": "Interface IClickedHitObject Implement this if you want notification of event when a Hit Object is pressed/collected/missed. Remember to call SetOnClickedHitObject(IClickedHitObject) before starting the game, for this to actually work. Namespace : MouseDance.Runtime.Callbacks Assembly : MouseDance.Runtime.dll Syntax public interface IClickedHitObject Methods OnClickedHitCircle(Int32, Int32, Single, Int32, Beatmap) Called by the BeatmapRunner when player clicks on a Hit Circle. Declaration void OnClickedHitCircle(int idxClicked, int idxThatNeedsToBePressed, float result, int gotBaseScore, Beatmap beatmap) Parameters Type Name Description Int32 idxClicked Index of Hit Circle pressed. Int32 idxThatNeedsToBePressed Index of Hit Object that needs to be pressed. If this doesn't match idxPressed, then player clicked on something they shouldn't yet. Single result Normalized value indicating if user pressed Hit Circle within correct time window. -1.0 to +1.0 is a hit. Any value outside that (lesser than -1.0 or greater than +1.0) means miss (negative for too early, positive for too late). 0.0 means user pressed exactly at Hit Circle's hit time. Int32 gotBaseScore The 50, 100, or 300 score that the press of this Hit Circle got. This value is not directly added to the player's score yet (because score will still be multiplied), just a representation of which time window the player pressed. OsuParsers.Beatmaps.Beatmap beatmap Data of the entire beatmap. Use beatmap.HitObjects[idxPressed] to get more data about the Hit Circle. OnClickedSliderHead(Int32, Int32, Single, Int32, Beatmap) Called by the BeatmapRunner when player clicks on a Slider head/start cap. Declaration void OnClickedSliderHead(int idxClicked, int idxThatNeedsToBePressed, float result, int gotBaseScore, Beatmap beatmap) Parameters Type Name Description Int32 idxClicked Index of Slider pressed. Int32 idxThatNeedsToBePressed Index of Hit Object that needs to be pressed. If this doesn't match idxPressed, then player clicked on something they shouldn't yet. Single result Normalized value indicating if user pressed slider's head within correct time window. -1.0 to +1.0 is a hit. Any value outside that (lesser than -1.0 or greater than +1.0) means miss (negative for too early, positive for too late). 0.0 means user pressed exactly at slider head's hit time. Int32 gotBaseScore The equivalent 50, 100, or 300 score that the press of this Slider Head would get. This score is not added to the player's score, just a representation of which time window the player pressed. OsuParsers.Beatmaps.Beatmap beatmap Data of the entire beatmap. Use beatmap.HitObjects[idxPressed] to get more data about the Slider. OnHitCircleDieOff(Int32, Beatmap) Called by the BeatmapRunner when a Hit Circle's time is up and player never clicked on it. Declaration void OnHitCircleDieOff(int hitCircleIdx, Beatmap beatmap) Parameters Type Name Description Int32 hitCircleIdx Hit Circle's Index among the entire beatmap. OsuParsers.Beatmaps.Beatmap beatmap Data of the entire beatmap. Use beatmap.HitObjects[hitCircleIdx] to get more data about the Hit Circle. OnSliderFinished(Int32, Single, Beatmap) Called when a Slider has finished (ball finished rolling through it). Declaration void OnSliderFinished(int sliderIdx, float completionPercent, Beatmap beatmap) Parameters Type Name Description Int32 sliderIdx Index of Slider that was finished. Single completionPercent 0.0 to 1.0 value of percent completion. 0.0 means 0%, 1.0 means 100%, 0.5 means 50%, etc. OsuParsers.Beatmaps.Beatmap beatmap Data of the entire beatmap. Use beatmap.HitObjects[sliderIdx] to get more data about the Slider."
  },
  "api/MouseDance.Runtime.Callbacks.ICustomCollectRule.html": {
    "href": "api/MouseDance.Runtime.Callbacks.ICustomCollectRule.html",
    "title": "Interface ICustomCollectRule | MouseDance User Docs",
    "keywords": "Interface ICustomCollectRule Implement this if you want to add custom rules on how Hit Objects are pressed. Remember to call SetCustomCollectRule(ICustomCollectRule) before starting the game, for this to actually work. Namespace : MouseDance.Runtime.Callbacks Assembly : MouseDance.Runtime.dll Syntax public interface ICustomCollectRule Methods AllowCollect(IHitObject, IReadOnlyList<IHitObject>) Called by the BeatmapRunner to check if player is allowed to proceed with pressing the Hit Object they clicked on. Declaration HitObjectReaction AllowCollect(IHitObject hitObject, IReadOnlyList<IHitObject> allPressed) Parameters Type Name Description IHitObject hitObject The Hit Object we are checking. IReadOnlyList < IHitObject > allPressed List of all Hit Objects pressed, in case player pressed on overlapping Hit Objects. This is sorted by Hit Object Index meaning first element in this list is the one that is visually topmost (in terms of Z-order) on the screen. If there is only one Hit Object pressed, then allPressed will only contain one element. Returns Type Description HitObjectReaction HitObjectReaction struct containing all info on how you want the Hit Object to react. Remarks This is called the same frame that IsPlayerInputDown returns true. It is called for each Hit Object found under the mouse (in case the player clicked on overlapping Hit Objects). AllowCollectSliderPart(IHitObject) Called by the BeatmapRunner to check if player is allowed to proceed with collecting a Slider Part that they're currently pressing on. Declaration bool AllowCollectSliderPart(IHitObject slider) Parameters Type Name Description IHitObject slider The Slider we're checking for. Returns Type Description Boolean Return true to allow the Slider Part to be collected."
  },
  "api/MouseDance.Runtime.Callbacks.IHitObjectSizeCalculator.html": {
    "href": "api/MouseDance.Runtime.Callbacks.IHitObjectSizeCalculator.html",
    "title": "Interface IHitObjectSizeCalculator | MouseDance User Docs",
    "keywords": "Interface IHitObjectSizeCalculator Implement this if you want to edit the size of each Hit Object just as they are about to be spawned. Make sure to call SetHitObjectSizeCalculator(IHitObjectSizeCalculator) before starting the game, for this to actually work. Namespace : MouseDance.Runtime.Callbacks Assembly : MouseDance.Runtime.dll Syntax public interface IHitObjectSizeCalculator Methods GetHitCircleRadius(Int32, Int32, Int32, HitCircle, Beatmap) Determine what radius will be for this Hit Circle. Declaration float GetHitCircleRadius(int idx, int comboCounter, int comboColourIdx, HitCircle hitCircle, Beatmap beatmap) Parameters Type Name Description Int32 idx Index position of the Hit Circle in the entire Beatmap. Starts at 0. Int32 comboCounter Number to be displayed on the Hit Circle. Int32 comboColourIdx What index of colour this Hit Circle is given. Starts at 0. OsuParsers.Beatmaps.Objects.HitCircle hitCircle Extra info about the Hit Circle. OsuParsers.Beatmaps.Beatmap beatmap Data on the entire Beatmap. Returns Type Description Single Radius (in osu!pixels) that the Hit Circle will be in. GetSliderCircleRadius(Int32, Int32, Int32, Slider, Beatmap) Determine what radius will be for this Slider. Declaration float GetSliderCircleRadius(int idx, int comboCounter, int comboColourIdx, Slider slider, Beatmap beatmap) Parameters Type Name Description Int32 idx Index position of this Slider in the entire Beatmap. Starts at 0. Int32 comboCounter Combo Number to be displayed on the Slider. Int32 comboColourIdx What index of colour this Slider is given. Starts at 0. OsuParsers.Beatmaps.Objects.Slider slider Extra info about the Slider. OsuParsers.Beatmaps.Beatmap beatmap Data on the entire Beatmap. Returns Type Description Single Radius (in osu!pixels) that the Slider will be in."
  },
  "api/MouseDance.Runtime.Callbacks.ISongStartCountdown.html": {
    "href": "api/MouseDance.Runtime.Callbacks.ISongStartCountdown.html",
    "title": "Interface ISongStartCountdown | MouseDance User Docs",
    "keywords": "Interface ISongStartCountdown Implement this if you want to be able to play your own countdown animation before the first Hit Object appears. Make sure to call SetSongStartCountdown(ISongStartCountdown) before starting the game, for this to actually work. Namespace : MouseDance.Runtime.Callbacks Assembly : MouseDance.Runtime.dll Syntax public interface ISongStartCountdown Properties CountdownLength How long your countdown animation is. This value should be in seconds. Declaration float CountdownLength { get; } Property Value Type Description Single Methods OnStartCountdown() Will be called once current song playtime is now at first hit object's time minus CountdownLength . Declaration void OnStartCountdown()"
  },
  "api/MouseDance.Runtime.Effects.html": {
    "href": "api/MouseDance.Runtime.Effects.html",
    "title": "Class Effects | MouseDance User Docs",
    "keywords": "Class Effects Common entry point for any visual effects prefab instantiated by the HitObjectManager . Inheritance Object Object Component Behaviour MonoBehaviour Effects Namespace : MouseDance.Runtime Assembly : MouseDance.Runtime.dll Syntax public class Effects : MonoBehaviour Methods Show(Vector3, Color, Single) Show the visual effects in the specified position, color, and scale. Declaration public virtual void Show(Vector3 newWorldPos, Color newColour, float scale) Parameters Type Name Description Vector3 newWorldPos Show the visual effects at this world-space position. Color newColour Show the visual effects with this colour. Single scale Show the visual effects with this scale. Extension Methods Util.SetLayerDeep(Component, LayerMask) Util.SetLayerDeep(Component, Int32) Util.SetLayerDeep(Component, LayerMask, Stack<Transform>)"
  },
  "api/MouseDance.Runtime.Gradient.html": {
    "href": "api/MouseDance.Runtime.Gradient.html",
    "title": "Struct Gradient | MouseDance User Docs",
    "keywords": "Struct Gradient Simple struct holding two Color32 that represents start and end of gradient. Used by SDFCurve . Namespace : MouseDance.Runtime Assembly : MouseDance.Runtime.dll Syntax [Serializable] public struct Gradient Constructors Gradient(Color32, Color32) Declaration public Gradient(Color32 sta, Color32 end) Parameters Type Name Description Color32 sta Color32 end Fields ColourEnd Declaration public Color32 ColourEnd Field Value Type Description Color32 ColourStart Declaration public Color32 ColourStart Field Value Type Description Color32 Extension Methods GraphicsUtil.Add(Gradient, Color32)"
  },
  "api/MouseDance.Runtime.GraphicsUtil.html": {
    "href": "api/MouseDance.Runtime.GraphicsUtil.html",
    "title": "Class GraphicsUtil | MouseDance User Docs",
    "keywords": "Class GraphicsUtil Utility code for geometrical functions needed by Sliders, and graphical code needed by other parts of the game. Inheritance Object GraphicsUtil Namespace : MouseDance.Runtime Assembly : MouseDance.Runtime.dll Syntax public static class GraphicsUtil Fields AntiAliasingSmoothness Id of shader property AntiAliasingSmoothness. Used in SDF shaders. Declaration public static readonly int AntiAliasingSmoothness Field Value Type Description Int32 AspectRatioX Id of shader property AspectRatioX. Used in SDF shaders. Declaration public static readonly int AspectRatioX Field Value Type Description Int32 AspectRatioY Id of shader property AspectRatioY. Used in SDF shaders. Declaration public static readonly int AspectRatioY Field Value Type Description Int32 BaseColour Id of shader property Base Colour. Used in SDF shaders. Declaration public static readonly int BaseColour Field Value Type Description Int32 BorderColour Id of shader property Border Colour (when shader displays a border). Used in SDF shaders. Declaration public static readonly int BorderColour Field Value Type Description Int32 CenterLineColour Id of shader property Center Line Colour (when shader displays a center line). Used in SDF shaders. Declaration public static readonly int CenterLineColour Field Value Type Description Int32 CurvePositionCount Id of shader property CurvePositionCount (when shader displays a list of points as a curve). Used in SDF Curve to know how many points there are. Declaration public static readonly int CurvePositionCount Field Value Type Description Int32 CurvePositions Id of shader property CurvePositions (when shader displays a list of points as a curve). Used in SDF Curve when structured buffers are supported. This is for passing a list of Vector2 to the shader. Declaration public static readonly int CurvePositions Field Value Type Description Int32 CurvePositionsX Id of shader property CurvePositionsX (when shader displays a list of points as a curve). Used in SDF Curve when structured buffers are not available. This is for passing a float array of a Vector2 's x-coordinate to the shader. Declaration public static readonly int CurvePositionsX Field Value Type Description Int32 CurvePositionsY Id of shader property CurvePositionsY (when shader displays a list of points as a curve). Used in SDF Curve when structured buffers are not available. This is for passing a float array of a Vector2 's y-coordinate to the shader. Declaration public static readonly int CurvePositionsY Field Value Type Description Int32 CurveShowPercent Id of shader property Curve Show Percent (when shader displays a list of points as a curve). Used in SDF Curve. Declaration public static readonly int CurveShowPercent Field Value Type Description Int32 LineEndPositionX Id of shader property LineEndPositionX. Used in SDF shaders. Declaration public static readonly int LineEndPositionX Field Value Type Description Int32 LineEndPositionY Id of shader property LineEndPositionY. Used in SDF shaders. Declaration public static readonly int LineEndPositionY Field Value Type Description Int32 LineMid1PositionX Id of shader property LineMid1PositionX. Used in SDF Lines. Declaration public static readonly int LineMid1PositionX Field Value Type Description Int32 LineMid1PositionY Id of shader property LineMid1PositionY. Used in SDF Lines. Declaration public static readonly int LineMid1PositionY Field Value Type Description Int32 LineMid2PositionX Id of shader property LineMid2PositionX. Used in SDF Lines. Declaration public static readonly int LineMid2PositionX Field Value Type Description Int32 LineMid2PositionY Id of shader property LineMid2PositionY. Used in SDF Lines. Declaration public static readonly int LineMid2PositionY Field Value Type Description Int32 LineStartPositionX Id of shader property LineStartPositionX. Used in SDF shaders. Declaration public static readonly int LineStartPositionX Field Value Type Description Int32 LineStartPositionY Id of shader property LineStartPositionY. Used in SDF shaders. Declaration public static readonly int LineStartPositionY Field Value Type Description Int32 LineThickness Id of shader property Line Thickness. Used in SDF shaders. Declaration public static readonly int LineThickness Field Value Type Description Int32 Opacity Id of shader property Opacity. Used in SDF shaders. Declaration public static readonly int Opacity Field Value Type Description Int32 OriginX Id of shader property OriginX. Used in SDF shaders. Declaration public static readonly int OriginX Field Value Type Description Int32 OriginY Id of shader property OriginY. Used in SDF shaders. Declaration public static readonly int OriginY Field Value Type Description Int32 OSU_PIXELS_CENTER_X X-axis center of a 640x480 screen. Declaration public const float OSU_PIXELS_CENTER_X = 256F Field Value Type Description Single OSU_PIXELS_CENTER_Y Y-axis center of a 640x480 screen. Declaration public const float OSU_PIXELS_CENTER_Y = 192F Field Value Type Description Single OSU_PIXELS_HEIGHT Height of the 640x480 screen. Declaration public const float OSU_PIXELS_HEIGHT = 480F Field Value Type Description Single OSU_PIXELS_WIDTH Width of the 640x480 screen. Declaration public const float OSU_PIXELS_WIDTH = 640F Field Value Type Description Single OuterBaseColour Id of shader property Outer Base Colour (when shader can do gradient between Base Colour and Outer Base Colour). Used in SDF shaders. Declaration public static readonly int OuterBaseColour Field Value Type Description Int32 ScreenScale Id of shader property ScreenScale. Used in SDF shaders. Declaration public static readonly int ScreenScale Field Value Type Description Int32 Methods Add(Gradient, Color32) Combine a Gradient 's start and end values additively with a Color32 . This brings the result closer to white. Declaration public static Gradient Add(this Gradient g, Color32 c) Parameters Type Name Description Gradient g Color32 c Returns Type Description Gradient A new Gradient of the combined value. Add(Color32, Color32) Combine two Color32 s additively. This brings the result closer to white. Declaration public static Color32 Add(this Color32 c1, Color32 c2) Parameters Type Name Description Color32 c1 Color32 c2 Returns Type Description Color32 A new Color32 of the combined value. CreateBezier(List<Vector2>, Int32, List<Vector2>) Create an N-order bezier curve and store it in a list of Vector2 . Declaration public static void CreateBezier(List<Vector2> resultingPoints, int positionCount, List<Vector2> points) Parameters Type Name Description List < Vector2 > resultingPoints Where the points of the resulting bezier curve is stored in. Int32 positionCount How many points you want the resulting curve to have. More points means smoother curve. List < Vector2 > points Control points for the curve, in world-space. Remarks Based on https://stackoverflow.com/a/31169371 CreateBezier(List<Vector3>, Int32, List<Vector2>) Create an N-order bezier curve and store it in a list of Vector3 . Declaration public static void CreateBezier(List<Vector3> resultingPoints, int positionCount, List<Vector2> points) Parameters Type Name Description List < Vector3 > resultingPoints Where the points of the resulting bezier curve is stored in. Values will be in the X and Y. Z will be set to 0. Int32 positionCount How many points you want the resulting curve to have. More points means smoother curve. List < Vector2 > points Control points for the curve, in world-space. Remarks Based on https://stackoverflow.com/a/31169371 Equal(Color32, Byte, Byte, Byte) Check if the specified Color32 is equal to the specific r, g, b values. Alpha value is ignored. Declaration public static bool Equal(this Color32 a, byte br, byte bg, byte bb) Parameters Type Name Description Color32 a Color32 to check. Byte br 0 - 255 red value to compare against. Byte bg 0 - 255 green value to compare against. Byte bb 0 - 255 blue value to compare against. Returns Type Description Boolean Returns true if color's values match the 0-255 values specified. EqualBlack(Color32) Check if the specified Color32 is black (0, 0, 0). Alpha value is ignored. Declaration public static bool EqualBlack(this Color32 a) Parameters Type Name Description Color32 a Returns Type Description Boolean Returns true if color is black. GetCircleCenterFromPoints(Vector2, Vector2, Vector2) Find a circle's center and radius, given 3 points found on its circumference. It doesn't matter if the 3 points are not sorted in any way, as long as they are all points on the circle's circumference. Declaration public static (Vector2 center, float radius) GetCircleCenterFromPoints(Vector2 p1, Vector2 p2, Vector2 p3) Parameters Type Name Description Vector2 p1 First point on the circle's circumference. Vector2 p2 Second point on the circle's circumference. Vector2 p3 Third point on the circle's circumference. Returns Type Description (T1, T2) < Vector2 , Single > Remarks Based on https://stackoverflow.com/a/22792054 Note: Explanation of answer in StackOverflow does square of a binomial, and Cramer's Rule (2x2 linear system). MakeArc(List<Vector2>, Int32, Single, Vector3, Vector3, Vector3, Boolean) Create a circular arc based on a center point, and a start and end point on the circumference. This stores the result in a list of Vector2 . Declaration public static void MakeArc(List<Vector2> resultingPoints, int positionCount, float radius, Vector3 centerPos, Vector3 startPt, Vector3 endPt, bool append = false) Parameters Type Name Description List < Vector2 > resultingPoints Where the resulting points of the arc will be stored. Int32 positionCount How many points you want the resulting arc to have. More points means smoother arc. Single radius Radius of the arc. Vector3 centerPos Center point of the arc. Vector3 startPt A point that lies on the circumference of the arc where you want it to start. Vector3 endPt A point that lies on the circumference of the arc where you want it to end. Boolean append Whether you want the result appended to the resultingPoints list, or if you want to clear that list first. MakeArc(List<Vector2>, Int32, Vector2, Vector2, Vector2) Create a circular arc, given 3 points found on its circumference. This stores the result in a list of Vector2 . Declaration public static void MakeArc(List<Vector2> resultingPoints, int positionCount, Vector2 startPt, Vector2 midPt, Vector2 endPt) Parameters Type Name Description List < Vector2 > resultingPoints Where the resulting points of the arc will be stored. Int32 positionCount How many points you want the resulting arc to have. More points means smoother arc. Vector2 startPt A point that lies on the circumference of the arc where you want it to start. Vector2 midPt A point that lies on the circumference of the arc that is between the startPt and endPt. Vector2 endPt A point that lies on the circumference of the arc where you want it to end. MakeArc(List<Vector3>, Int32, Single, Vector3, Vector3, Vector3, Boolean) Create a circular arc based on a center point, and a start and end point on the circumference. This stores the result in a list of Vector3 . Declaration public static void MakeArc(List<Vector3> resultingPoints, int positionCount, float radius, Vector3 centerPos, Vector3 startPt, Vector3 endPt, bool append = false) Parameters Type Name Description List < Vector3 > resultingPoints Where the resulting points of the arc will be stored. Values will be in the X and Y. Z will be set to 0. Int32 positionCount How many points you want the resulting arc to have. More points means smoother arc. Single radius Radius of the arc. Vector3 centerPos Center point of the arc. Vector3 startPt A point that lies on the circumference of the arc where you want it to start. Vector3 endPt A point that lies on the circumference of the arc where you want it to end. Boolean append Whether you want the result appended to the resultingPoints list, or if you want to clear that list first. MakeArc(List<Vector3>, Int32, Vector2, Vector2, Vector2) Create a circular arc, given 3 points found on its circumference. This stores the result in a list of Vector3 . Declaration public static void MakeArc(List<Vector3> resultingPoints, int positionCount, Vector2 startPt, Vector2 midPt, Vector2 endPt) Parameters Type Name Description List < Vector3 > resultingPoints Where the resulting points of the arc will be stored. Values will be in the X and Y. Z will be set to 0. Int32 positionCount How many points you want the resulting arc to have. More points means smoother arc. Vector2 startPt A point that lies on the circumference of the arc where you want it to start. Vector2 midPt A point that lies on the circumference of the arc that is between the startPt and endPt. Vector2 endPt A point that lies on the circumference of the arc where you want it to end. NormalizedPingPong(Single) Returns value that linearly goes from 0.0 to 1.0, then back to 0.0. Input t is expected to go from 0.0 to 1.0. Declaration public static float NormalizedPingPong(float t) Parameters Type Name Description Single t Returns Type Description Single ScalePointFromCenter(Vector2, Single) Move point nearer or farther from center of screen, assuming the screen has a size of 640x480. Declaration public static Vector2 ScalePointFromCenter(this Vector2 point, float scale) Parameters Type Name Description Vector2 point The point to be scaled. Single scale Multiplier on the point. 1.0 leaves the value unchanged. 2.0 places the point twice as far from the center. 0.5 places the point nearer the center, about halfway from its original position. etc. Returns Type Description Vector2 A new Vector2 of the scaled value. SetAlpha(Graphic, Single) Simple quick way to set a Unity UI Graphic's alpha, while keeping the rest of the colour the same. Declaration public static void SetAlpha(this Graphic i, float newAlpha) Parameters Type Name Description UnityEngine.UI.Graphic i Graphic component to edit. Single newAlpha New alpha value to be given."
  },
  "api/MouseDance.Runtime.HitCircle.html": {
    "href": "api/MouseDance.Runtime.HitCircle.html",
    "title": "Class HitCircle | MouseDance User Docs",
    "keywords": "Class HitCircle Graphical representation of a Hit Circle, displayed on the Beatmap Canvas by the HitObjectManager , and checked for mouse click by the BeatmapRunner . Inheritance Object Object Component Behaviour MonoBehaviour HitCircle Implements IHitObjectWithEvents IHitObject Namespace : MouseDance.Runtime Assembly : MouseDance.Runtime.dll Syntax public class HitCircle : MonoBehaviour, IHitObjectWithEvents, IHitObject Remarks The Hit Circle takes care of its own animations, such as fading in and out, doing the \"shrinking\" animation for the Approach Circle, doing a shake animation when player pressed it out of sequence. Hit and miss visual effects on the other hand, are handled by the HitObjectManager . Fields APPROACH_CIRCLE_FADE_IN_MULTIPLIER How long the approach circle fades in. This value isn't the actual duration, but a multiplier on the Approach Rate Duration. Meaning a value of 1.0 means to use the Approach Rate Duration (0.5 would be half, 2.0 would be double, etc). This value is just guessed, based on playing Osu! . Declaration public const float APPROACH_CIRCLE_FADE_IN_MULTIPLIER = 0.4F Field Value Type Description Single APPROACH_CIRCLE_RADIUS_MULTIPLIER How bigger than the hit circle the approach circle starts at. This value isn't the actual radius, but a multiplier on the hit circle's radius (2 means double the hit circle's radius). This value is just guessed, based on playing Osu! . Declaration public const float APPROACH_CIRCLE_RADIUS_MULTIPLIER = 4.2F Field Value Type Description Single DIE_OFF_FADE_OUT_DURATION Once the hit circle's lifetime is over (and player never managed to press/collect it), it fades-out. This is how long to fade it out (in milliseconds). This value is just guessed, based on playing Osu! . Declaration public const float DIE_OFF_FADE_OUT_DURATION = 125F Field Value Type Description Single HIT_CIRCLE_FADE_IN_PAUSE_DURATION_MULTIPLIER Before the hit circle goes to full opacity, it pauses halfway for this duration. This value isn't the actual duration, but a multiplier on the Approach Rate Duration. Meaning a value of 1.0 means to use the Approach Rate Duration (0.5 would be half, 2.0 would be double, etc). This value is just guessed, based on playing Osu! . Declaration public const float HIT_CIRCLE_FADE_IN_PAUSE_DURATION_MULTIPLIER = 0.5F Field Value Type Description Single HIT_CIRCLE_FULL_FADE_IN_DURATION_MULTIPLIER Before the hit circle goes to full opacity, it pauses halfway, then finally fades-in to full opacity using this duration. This value isn't the actual duration, but a multiplier on the Approach Rate Duration. Meaning a value of 1.0 means to use the Approach Rate Duration (0.5 would be half, 2.0 would be double, etc). This value is just guessed, based on playing Osu! . Declaration public const float HIT_CIRCLE_FULL_FADE_IN_DURATION_MULTIPLIER = 0.3F Field Value Type Description Single HIT_CIRCLE_PARTIAL_FADE_IN_DURATION_MULTIPLIER Before the hit circle goes to full opacity, it fades in to this value first, then pauses for a while. This value isn't the actual duration, but a multiplier on the Approach Rate Duration. Meaning a value of 1.0 means to use the Approach Rate Duration (0.5 would be half, 2.0 would be double, etc). This value is just guessed, based on playing Osu! . Declaration public const float HIT_CIRCLE_PARTIAL_FADE_IN_DURATION_MULTIPLIER = 0.2F Field Value Type Description Single Properties Colour Colour that this Hit Circle is in. Used by visual effects so that their colour matches the Hit Circle's colour. Declaration public Color Colour { get; } Property Value Type Description Color ComboColourIndex The index of the colour used by this Hit Circle. This can be used to identify or differentiate this Hit Circle from other Hit Objects that are using a different colour. Declaration public int ComboColourIndex { get; } Property Value Type Description Int32 ComboCounter The number displayed on this Hit Circle. Declaration public int ComboCounter { get; } Property Value Type Description Int32 EffectsPos When this Hit Circle is pressed or missed, this is the position where the visual effects should spawn in. Declaration public Vector3 EffectsPos { get; } Property Value Type Description Vector3 An (x, y, z) position Remarks This is an (x, y, z) position, though the z value is 0 and can be ignored. The only reason why this is a Vector3 and not a Vector2 is so that this value can be easily assigned to a Transform 's position . Index Index position of this Hit Circle in the entire Beatmap. Starts at 0. Declaration public int Index { get; } Property Value Type Description Int32 IsEnabled Informs the BeatmapRunner whether it should consider this Hit Circle as hittable or not. Disabled Hit Circles are \"despawned\" and are back into the pool and therefore should not be used. Declaration public bool IsEnabled { get; } Property Value Type Description Boolean True: This Hit Circle is \"enabled\", currently being used and is on-screen. False: This Hit Circle is considered to be \"disabled\", currently hidden and not in-use (but is ready to be re-used). PoolId Which pool of prefabs this Hit Circle prefab will belong to. Important once it's time to despawn this Hit Circle. Declaration public string PoolId { get; } Property Value Type Description String Pressed Whether this Hit Circle has been pressed already. Declaration public bool Pressed { get; } Property Value Type Description Boolean True: Hit Circle has already been pressed. False: This Hit Circle is yet to be pressed. RequiresHold Does this Hit Object need to be pressed for a long time? For Hit Circles, this always returns false. Declaration public bool RequiresHold { get; } Property Value Type Description Boolean Methods DoShakeAnimation(String) Make the Hit Circle do a shaking animation with the appropriate sound effect. Declaration public void DoShakeAnimation(string effectsId = null) Parameters Type Name Description String effectsId Optional ID of the specific visual/sound effect to play. Leave at null to use defaults. Hide() Hide this Hit Circle immediately (no fade out). Declaration public void Hide() IsNameMatch(String) Is specified name the kind of name assigned to Hit Circles? Declaration public static bool IsNameMatch(string name) Parameters Type Name Description String name Returns Type Description Boolean OnPressed(Int32) Called by the BeatmapRunner to notify this Hit Circle that it's been pressed by the player. This makes the Hit Circle react properly (do a shake animation if pressed out-of-sequence, fade-out if pressed correctly, trigger appropriate hit/miss sound/visual fx) Declaration public void OnPressed(int idxThatNeedsToBePressed) Parameters Type Name Description Int32 idxThatNeedsToBePressed The current Hit Object index that should be pressed right now. If this doesn't match the Hit Circle's own Index , then the player clicked out-of-sequence. OnReleased() Called by the BeatmapRunner to notify this Hit Circle that the player released their press on it. Declaration public void OnReleased() OnWrongPressed(String) Called by the BeatmapRunner to notify this Hit Circle that it's been pressed by the player, but somehow pressed it wrong (which is determined by a AllowCollect(IHitObject, IReadOnlyList<IHitObject>) ). Declaration public void OnWrongPressed(string effectsId = null) Parameters Type Name Description String effectsId Optional ID of the specific visual/sound effect to play. Leave at null to use defaults. Resize(Single, Single) Resize this Hit Circle with specified radius. Declaration public void Resize(float radius, float radiusMultiplier) Parameters Type Name Description Single radius Size of Hit Circle in pixel radius. Single radiusMultiplier Multiplier to the radius coming from CircleRadiusMultiplier . Show(HitObjectManager, BeatmapRunner, String, Int32, Int32, Int32, Gradient, Color32, Boolean, Boolean, HitCircle, Single, Single, Single, Single, Single) Show this Hit Circle at specified position, colour, and other properties. This overload also initializes the Hit Circle's reference to the HitObjectManager and BeatmapRunner , and is called for newly instantiated Hit Circles. Declaration public void Show(HitObjectManager manager, BeatmapRunner beatmapRunner, string poolId, int idx, int comboCounter, int comboColourIdx, Gradient colour, Color32 borderColour, bool applyColourToApproachCircles, bool showNumber, HitCircle hitCircle, float positionScale, float radius, float radiusMultiplier, float approachStartDelay, float approachRateDuration) Parameters Type Name Description HitObjectManager manager Which HitObjectManager manages this HitCircle. Needed to allow this Hit Circle to be despawned and moved back to pool for reusing, and for reporting when user has pressed the Hit Circle right or wrong so it can play the proper sound/visual fx. BeatmapRunner beatmapRunner Needed to report to the game when user pressed the Hit Circle for keeping score. String poolId Which pool of prefabs this Hit Circle will belong to. Int32 idx Numerical position of this Hit Circle in the entire Beatmap. Int32 comboCounter The number that should be displayed in this Hit Circle. Int32 comboColourIdx The index of the colour used by this Hit Circle. This can be used to identify or differentiate this Hit Object from others using a different colour. Gradient colour Colour that this Hit Circle should be in. Color32 borderColour Colour that this Hit Circle's borders should be in. Boolean applyColourToApproachCircles Whether specified colour should also be applied to the Approach Circle. If false, Approach Circle will just be white. Boolean showNumber Whether to show the number on this Hit Circle or not. OsuParsers.Beatmaps.Objects.HitCircle hitCircle More data on this Hit Circle. Single positionScale How far from the center of the screen this Hit Circle should be placed. This is a multiplier so 2.0 will place this twice as far from the center of the screen. Set to 1.0 if you do not want any scaling. Single radius Size of Hit Circle in pixel radius. Single radiusMultiplier Multiplier to the size coming from CircleRadiusMultiplier . Single approachStartDelay How long do we delay the Approach Circle from showing up and doing its shrinking animation. Used when the Hit Circle is shown in advance, even earlier than its preempt duration. Set to 0 if you do not want a delay. Single approachRateDuration How long it will take for the Approach Circle to do its shrinking animation. Show(String, Int32, Int32, Int32, Gradient, Color32, Boolean, Boolean, HitCircle, Single, Single, Single, Single, Single) Show this Hit Circle at specified position, colour, and other properties. This is called on reused Hit Circles. Declaration public void Show(string poolId, int idx, int comboCounter, int comboColourIdx, Gradient colour, Color32 borderColour, bool applyColourToApproachCircles, bool showNumber, HitCircle hitCircle, float positionScale, float radius, float radiusMultiplier, float approachStartDelay, float approachRateDuration) Parameters Type Name Description String poolId Which pool of prefabs this Hit Circle will belong to. Int32 idx Numerical position of this Hit Circle in the entire Beatmap. Int32 comboCounter The number that should be displayed in this Hit Circle. Int32 comboColourIdx The index of the colour used by this Hit Object. This can be used to identify or differentiate this Hit Object from others using a different colour. Gradient colour Colour that this Hit Circle should be in. Color32 borderColour Colour that this Hit Circle's borders should be in. Boolean applyColourToApproachCircles Whether specified colour should also be applied to the Approach Circle. If false, Approach Circle will just be white. Boolean showNumber Whether to show the number on this Hit Circle or not. OsuParsers.Beatmaps.Objects.HitCircle hitCircle More data on this Hit Circle. Single positionScale How far from the center of the screen this Hit Circle should be placed. This is a multiplier so 2.0 will place this twice as far from the center of the screen. Set to 1.0 if you do not want any scaling. Single radius Size of Hit Circle in pixel radius. Single radiusMultiplier Multiplier to the size coming from CircleRadiusMultiplier . Single approachStartDelay How long do we delay the Approach Circle from showing up and doing its shrinking animation. Used when the Hit Circle is shown in advance, even earlier than its preempt duration. Set to 0 if you do not want a delay. Single approachRateDuration How long it will take for the Approach Circle to do its shrinking animation. Update() Update method called by Unity every frame. This is used to update the Hit Circle's animations (Approach Circle shrinking animation, fading in and out, shake animation). Declaration public void Update() Implements IHitObjectWithEvents IHitObject Extension Methods Util.SetLayerDeep(Component, LayerMask) Util.SetLayerDeep(Component, Int32) Util.SetLayerDeep(Component, LayerMask, Stack<Transform>)"
  },
  "api/MouseDance.Runtime.HitEffectsSet.CustomVisualEffect.html": {
    "href": "api/MouseDance.Runtime.HitEffectsSet.CustomVisualEffect.html",
    "title": "Struct HitEffectsSet.CustomVisualEffect | MouseDance User Docs",
    "keywords": "Struct HitEffectsSet.CustomVisualEffect Struct for specifying custom visual effects prefabs, identified by a string ID. Used for custom rules in a AllowCollect(IHitObject, IReadOnlyList<IHitObject>) . Namespace : MouseDance.Runtime Assembly : MouseDance.Runtime.dll Syntax [Serializable] public struct CustomVisualEffect Fields Effects Declaration public Effects Effects Field Value Type Description Effects ID Declaration public string ID Field Value Type Description String"
  },
  "api/MouseDance.Runtime.HitEffectsSet.html": {
    "href": "api/MouseDance.Runtime.HitEffectsSet.html",
    "title": "Class HitEffectsSet | MouseDance User Docs",
    "keywords": "Class HitEffectsSet All prefabs needed by HitObjectManager to hit/miss effects, grouped for easy reference. Inheritance Object Object ScriptableObject HitEffectsSet Namespace : MouseDance.Runtime Assembly : MouseDance.Runtime.dll Syntax [CreateAssetMenu(fileName = \"HitEffectsSet\", menuName = \"MouseDance/HitEffectsSet\")] public class HitEffectsSet : ScriptableObject, ISerializationCallbackReceiver Fields _CustomVisualEffect Declaration [Space(20F)] [Tooltip(\"Custom visual effects meant for use in custom rules.\")] public List<HitEffectsSet.CustomVisualEffect> _CustomVisualEffect Field Value Type Description List < HitEffectsSet.CustomVisualEffect > CustomEffects Declaration public Dictionary<string, Effects> CustomEffects Field Value Type Description Dictionary < String , Effects > DefaultHitEffectsPrefab Declaration [Tooltip(\"Default Effects that will play when user successfully pressed a hit object. Used if there is nothing assigned in the score-specific hit effects.\")] public Effects DefaultHitEffectsPrefab Field Value Type Description Effects MissEffectsPrefab Declaration [Tooltip(\"Effects that will play when user was not able to press a hit object at all. This plays as the hit object disappears.\")] public Effects MissEffectsPrefab Field Value Type Description Effects Score100HitEffectsPrefab Declaration [Tooltip(\"Effects that will play when user successfully pressed a hit object within the 100 score hit-window. If not assigned, the Default Hit Effects Prefab is used instead.\")] public Effects Score100HitEffectsPrefab Field Value Type Description Effects Score300HitEffectsPrefab Declaration [Tooltip(\"Effects that will play when user successfully pressed a hit object within the 300 score hit-window. This is also used if user hit a Slider perfectly (head, tail, and all ticks were pressed). If not assigned, the Default Hit Effects Prefab is used instead.\")] public Effects Score300HitEffectsPrefab Field Value Type Description Effects Score50HitEffectsPrefab Declaration [Tooltip(\"Effects that will play when user successfully pressed a hit object within the 50 score hit-window. If not assigned, the Default Hit Effects Prefab is used instead.\")] public Effects Score50HitEffectsPrefab Field Value Type Description Effects Methods OnAfterDeserialize() Declaration public void OnAfterDeserialize() OnBeforeSerialize() Declaration public void OnBeforeSerialize()"
  },
  "api/MouseDance.Runtime.HitObjectColours.html": {
    "href": "api/MouseDance.Runtime.HitObjectColours.html",
    "title": "Class HitObjectColours | MouseDance User Docs",
    "keywords": "Class HitObjectColours Combo Colours used by Hit Objects, and some simple tweaks with how they are applied. Inheritance Object Object ScriptableObject HitObjectColours Namespace : MouseDance.Runtime Assembly : MouseDance.Runtime.dll Syntax [CreateAssetMenu(fileName = \"HitObjectColours\", menuName = \"MouseDance/HitObjectColours\")] public class HitObjectColours : ScriptableObject Fields ApplyBorderColourToHitCircles Declaration [Tooltip(\"True: Hit Circle borders will be coloured using the Border colour in the list.\\n\\nFalse: Hit Circle borders will always be white.\")] public bool ApplyBorderColourToHitCircles Field Value Type Description Boolean ApplyBorderColourToSliderRepeatArrow Declaration [Tooltip(\"True: Repeat Arrow of Sliders will be coloured using the Border colour in the list.\\n\\nFalse: Repeat Arrow of Sliders will always be white.\")] public bool ApplyBorderColourToSliderRepeatArrow Field Value Type Description Boolean ApplyBorderColourToSliders Declaration [Tooltip(\"True: Slider borders (and ticks) will be coloured using the Border colour in the list.\\n\\nFalse: Slider borders (and ticks) will always be white.\")] public bool ApplyBorderColourToSliders Field Value Type Description Boolean ApplyColourToApproachCircles Declaration [Tooltip(\"True: Colourise the Approach Circles with the same colour of their Hit Object.\\n\\nFalse: Approach Circles will always be coloured white.\")] public bool ApplyColourToApproachCircles Field Value Type Description Boolean ColoursForBorder Declaration [Tooltip(\"Colour to use for Borders. These colours are cycled through, just like for the GradientColours.\")] public List<Color32> ColoursForBorder Field Value Type Description List < Color32 > ColoursForSliderBall Declaration [Tooltip(\"Colour that the Slider Ball will use for the corresponding colour in the GradientColours. These colours are cycled through, just like for the GradientColours.\")] public List<Color32> ColoursForSliderBall Field Value Type Description List < Color32 > GradientColours Declaration [Tooltip(\"Colours that the Hit Objects will use. These colours are cycled through every time a Hit Object represents a new \\\"combo\\\".\\n\\nSliders will use the Gradient.\\n\\nHit Circles will only use the End Colour of the Gradient.\")] public List<Gradient> GradientColours Field Value Type Description List < Gradient > PreferUsingColourDataFromOsuFile Declaration [Tooltip(\"True: Ignore the colours assigned in here and use the colours specified in the .osu file. But, if the .osu file has no colour data, use the colours here.\\n\\nFalse: Always use the colours specified here.\")] public bool PreferUsingColourDataFromOsuFile Field Value Type Description Boolean"
  },
  "api/MouseDance.Runtime.HitObjectManager.html": {
    "href": "api/MouseDance.Runtime.HitObjectManager.html",
    "title": "Class HitObjectManager | MouseDance User Docs",
    "keywords": "Class HitObjectManager Responsible for spawning and pooling Hit Objects and visual effects, plus playing any sound effects. Inheritance Object Object Component Behaviour MonoBehaviour HitObjectManager Namespace : MouseDance.Runtime Assembly : MouseDance.Runtime.dll Syntax public class HitObjectManager : MonoBehaviour Properties GetHitObjectSizeCalculatorType Declaration public Type GetHitObjectSizeCalculatorType { get; } Property Value Type Description Type HasHitObjectSizeCalculator Declaration public bool HasHitObjectSizeCalculator { get; } Property Value Type Description Boolean Methods CleanUp() Despawn all currently used instances. Used when player chooses to restart the beatmap. Declaration public void CleanUp() Despawn(HitCircle) Mark a Hit Circle as now completely used up, so that it is ready to be re-used later on. Declaration public void Despawn(HitCircle hitCircle) Parameters Type Name Description HitCircle hitCircle Despawn(Slider) Mark a Slider as now completely used up, so that it is ready to be re-used later on. Declaration public void Despawn(Slider slider) Parameters Type Name Description Slider slider DespawnSliderTick(SliderTick) Mark a Slider Tick as now completely used up, so that it is ready to be re-used later on. Declaration public void DespawnSliderTick(SliderTick sliderTick) Parameters Type Name Description SliderTick sliderTick GetHitObjectByName(String) Get a reference to a currently used Hit Object based on the GameObject name. Declaration public IHitObjectWithEvents GetHitObjectByName(string gameObjectName) Parameters Type Name Description String gameObjectName Returns Type Description IHitObjectWithEvents GetSliderByIndex(Int32) Get a reference to a Slider based on its index. Declaration public ISlider GetSliderByIndex(int idx) Parameters Type Name Description Int32 idx Returns Type Description ISlider OnHit(IHitObject, Single, Int32) Spawns effects and/or plays hit sound for when user successfully hit a Hit Circle. Declaration public void OnHit(IHitObject hitObject, float result, int score) Parameters Type Name Description IHitObject hitObject The Hit Circle that was hit. Single result Normalized value indicating if user pressed within correct time window. -1 to +1 is a hit. Any value outside that (lesser than -1 or greater than +1) means miss (negative for too early, positive for too late). 0 means user pressed exactly at hit circle's time. Int32 score score given for this particular pressed hit circle OnHitOutOfSequence(IHitObject, String) Spawns effects and/or plays error sound meant for when user tries to hit a hit object that isn't supposed to be hit yet (e.g. trying to hit 2 when 1 hasn't been hit yet). Declaration public void OnHitOutOfSequence(IHitObject hitObject, string effectsId = null) Parameters Type Name Description IHitObject hitObject Used for figuring out where to position the visual effects and what colour to give it, if any. String effectsId Optional. Identifier for the visual/sound effect you want to be played. Leave at null to use defaults. OnHitSliderEnd(IHitObject, SliderReachType, Boolean, Boolean, Int32, Int32, Int32, Boolean) Spawns effects and/or plays hit sound for when user successfully keeps holding mouse down on the slider ball once it has finished going through a slider. Declaration public void OnHitSliderEnd(IHitObject slider, SliderReachType reachType, bool reachedEnd, bool userHit, int headScore = -1, int partsPressed = -1, int partsTotal = -1, bool wasReleased = true) Parameters Type Name Description IHitObject slider The slider whose tail was hit. SliderReachType reachType Whether the ball has reached the Slider's tail or head. Boolean reachedEnd True: ball has reached the end of movement for this Slider, there are no more repeats. False: Ball will repeat movement on this slider. Boolean userHit Whether mouse was pressed down and near enough the ball at the moment. Int32 headScore Determines whether player did a perfect press on the Slider head (start cap) or not. Int32 partsPressed Number of Slider parts that the player successfully hit (head, ticks, tail). Int32 partsTotal Number of parts that the Slider has (head, ticks, tail). Boolean wasReleased Did user ever release the mouse button when the slider was pressed? OnHitSliderStart(IHitObject) Spawns effects and/or plays hit sound for when user successfully hits Slider Head at the start of the Slider time. Declaration public void OnHitSliderStart(IHitObject slider) Parameters Type Name Description IHitObject slider OnHitSliderTick(SliderTick, Boolean) Called when Slider Ball reached a Slider Tick so that it can be removed and play the corresponding hit sound. Declaration public void OnHitSliderTick(SliderTick sliderTick, bool didUserHitTick) Parameters Type Name Description SliderTick sliderTick Boolean didUserHitTick OnHitTooEarly(IHitObject) Spawns effects and/or plays error sound meant for when user tries to hit a hit object that was supposed to be hit, but it's not yet time to hit it. Declaration public void OnHitTooEarly(IHitObject hitObject) Parameters Type Name Description IHitObject hitObject OnHitTooLate(IHitObject) Spawns effects and/or plays error sound meant for when user tries to hit a hit object that was supposed to be hit, but whose time is already up. Declaration public void OnHitTooLate(IHitObject hitObject) Parameters Type Name Description IHitObject hitObject OnHitWrong(IHitObject, String) Spawns effects and/or plays error sound meant for when user tries to hit a hit object but is somehow not allowed. Declaration public void OnHitWrong(IHitObject hitObject, string effectsId = null) Parameters Type Name Description IHitObject hitObject Used for figuring out where to position the visual effects and what colour to give it, if any. String effectsId Optional. Identifier for the visual/sound effect you want to be played. Leave at null to use defaults. OnMiss(IHitObject) Spawns effects and/or plays sound for when user missed a Hit Object. Declaration public void OnMiss(IHitObject hitObject) Parameters Type Name Description IHitObject hitObject RecalculateDisplayedHitObjectSize() Recalculate the size of currently displayed Hit Objects. Declaration public void RecalculateDisplayedHitObjectSize() SetBeatmap(Beatmap) Declaration public void SetBeatmap(Beatmap newBeatmap) Parameters Type Name Description OsuParsers.Beatmaps.Beatmap newBeatmap SetColours(BeatmapColoursSection) Declaration public void SetColours(BeatmapColoursSection newColours) Parameters Type Name Description OsuParsers.Beatmaps.Sections.BeatmapColoursSection newColours SetHitObjectSizeCalculator(IHitObjectSizeCalculator) Declaration public void SetHitObjectSizeCalculator(IHitObjectSizeCalculator newHitObjectSizeCalculator) Parameters Type Name Description IHitObjectSizeCalculator newHitObjectSizeCalculator SetInput(IBeatmapInput) Declaration public void SetInput(IBeatmapInput newBeatmapInput) Parameters Type Name Description IBeatmapInput newBeatmapInput Spawn(BeatmapRunner, Double, Int32, Int32, HitCircle, Single, Single, Single, Beatmap) Spawn a Hit Circle with the specified position, colour, etc. This will re-use existing instances when possible. Declaration public void Spawn(BeatmapRunner beatmapRunner, double beatLength, int offsetToComboIdx, int idx, HitCircle hitCircle, float positionScale, float approachStartDelay, float approachRateDuration, Beatmap beatmap) Parameters Type Name Description BeatmapRunner beatmapRunner Needed by the Hit Circle so it can report to the game when player pressed that Hit Circle. This also lets the Hit Circle know if the player pressed too early or not, and how much score the player got. Double beatLength Duration of a beat, in milliseconds. Int32 offsetToComboIdx Skip combo index so this Hit Circle can be at a specific colour. Hit Circles already have a ComboOffset from their data in osu, but this can be used to add even more offset. Int32 idx Numerical position of the Hit Circle in the entire Beatmap. OsuParsers.Beatmaps.Objects.HitCircle hitCircle More data on this Hit Circle. Single positionScale How far from the center of the screen this Hit Circle should be placed. This is a multiplier so 2.0 will place this twice as far from the center of the screen. Set to 1.0 if you do not want any scaling. Single approachStartDelay Single approachRateDuration How long it will take for the Approach Circle to do its shrinking animation. OsuParsers.Beatmaps.Beatmap beatmap Data on the entire Beatmap. Spawn(IBeatmapRunner, Double, Int32, Int32, Slider, Single, Single, Beatmap) Spawn a Slider with the specified position, colour, etc. This will re-use existing instances when possible. Declaration public void Spawn(IBeatmapRunner beatmapRunner, double beatLength, int offsetToComboIdx, int idx, Slider slider, float positionScale, float approachRateDuration, Beatmap beatmap) Parameters Type Name Description IBeatmapRunner beatmapRunner Needed by the Slider so it can report to the game when player pressed that Slider's head. This also lets the Slider know if the player pressed too early or not. Double beatLength Duration of a beat, in milliseconds. Int32 offsetToComboIdx Skip combo index so this Slider can be at a specific colour. Sliders already have a ComboOffset from their data in osu, but this can be used to add even more offset. Int32 idx Numerical position of the Slider in the entire Beatmap. OsuParsers.Beatmaps.Objects.Slider slider More data on this Slider. Single positionScale How far from the center of the screen this Slider should be placed. This is a multiplier so 2.0 will place this twice as far from the center of the screen. Set to 1.0 if you do not want any scaling. Single approachRateDuration How long it will take for the Approach Circle to do its shrinking animation. OsuParsers.Beatmaps.Beatmap beatmap Data on the entire Beatmap. SpawnSDFCurve(Slider, Single, Single, Gradient, Color) Used by Sliders to spawn the SDF Curve for it. Declaration public SDFCurve SpawnSDFCurve(Slider slider, float radius, float sliderSizeMultiplier, Gradient colour, Color borderColour) Parameters Type Name Description OsuParsers.Beatmaps.Objects.Slider slider Slider that this SDF Curve will be for Single radius The radius that the Slider has, based on OsuParsers.Beatmaps.Sections.BeatmapDifficultySection.CircleSize . Single sliderSizeMultiplier Multiplier to the size provided by the Slider. Gradient colour Gradient colour for the curve Color borderColour Colour for the curve's border Returns Type Description SDFCurve SpawnSliderTick(Vector2, Color32) Spawn a Slider Tick at the specified position. This will re-use existing instances when possible. Declaration public SliderTick SpawnSliderTick(Vector2 pos, Color32 colour) Parameters Type Name Description Vector2 pos Position that the Slider Tick will be in. Color32 colour Colour that the Slider Tick will be in. Returns Type Description SliderTick Extension Methods Util.SetLayerDeep(Component, LayerMask) Util.SetLayerDeep(Component, Int32) Util.SetLayerDeep(Component, LayerMask, Stack<Transform>)"
  },
  "api/MouseDance.Runtime.HitObjectManagerSettings.html": {
    "href": "api/MouseDance.Runtime.HitObjectManagerSettings.html",
    "title": "Class HitObjectManagerSettings | MouseDance User Docs",
    "keywords": "Class HitObjectManagerSettings Values for tweaking Hit Objects Inheritance Object Object ScriptableObject HitObjectManagerSettings Namespace : MouseDance.Runtime Assembly : MouseDance.Runtime.dll Syntax [CreateAssetMenu(fileName = \"HitObjectManagerSettings\", menuName = \"MouseDance/HitObjectManagerSettings\")] public class HitObjectManagerSettings : ScriptableObject Fields CircleRadiusMultiplier Declaration [Tooltip(\"Allows you to scale Hit Objects bigger or smaller than their normal size. 1.0 means no change. Greater than 1 means bigger, lesser than 1 means smaller. This multiplier is applied on top of the Osu file's \\\"Circle Size\\\" setting, allowing you to scale it even further than what Osu allows. Take note that this won't compensate for the Hit Object positions, so making them large will most likely make them overlap with each other.\")] public float CircleRadiusMultiplier Field Value Type Description Single HitObjectLayer Declaration [Tooltip(\"Which layer instantiated Hit Objects will be in.\")] [ShowIf(\"HitObjectLayerSpawnType\", ComparisonType.Equals, LayerSpawnType.UseSpecificLayer, HideType.DoNotDraw)] public LayerMask HitObjectLayer Field Value Type Description LayerMask HitObjectLayerSpawnType Declaration [Header(\"Hit Object Properties\")] [Tooltip(\"Whether we set a specific layer for instantiated Hit Objects or not.\")] public LayerSpawnType HitObjectLayerSpawnType Field Value Type Description LayerSpawnType PlayMissEffects Declaration public bool PlayMissEffects Field Value Type Description Boolean ShowNumbers Declaration [Tooltip(\"Display numbers on the Hit Objects or not.\")] public bool ShowNumbers Field Value Type Description Boolean VisualEffectsLayer Declaration [Tooltip(\"Which layer instantiated visual effect prefabs will be in.\")] [ShowIf(\"VisualEffectsLayerSpawnType\", ComparisonType.Equals, LayerSpawnType.UseSpecificLayer, HideType.DoNotDraw)] public LayerMask VisualEffectsLayer Field Value Type Description LayerMask VisualEffectsLayerSpawnType Declaration [Header(\"Visual Effects\")] [Tooltip(\"Whether we set a specific layer for instantiated visual effect prefabs or not.\")] public LayerSpawnType VisualEffectsLayerSpawnType Field Value Type Description LayerSpawnType VisualEffectsScale Declaration [Tooltip(\"Scale Visual Effects larger or smaller than their default size.\")] public float VisualEffectsScale Field Value Type Description Single"
  },
  "api/MouseDance.Runtime.HitObjectReaction.html": {
    "href": "api/MouseDance.Runtime.HitObjectReaction.html",
    "title": "Struct HitObjectReaction | MouseDance User Docs",
    "keywords": "Struct HitObjectReaction How you want a Hit Object to react to being clicked on. Namespace : MouseDance.Runtime Assembly : MouseDance.Runtime.dll Syntax public struct HitObjectReaction Fields EffectsId Optional identifier for the sound/visual effects you want to be played. Only applies to Hit Circles. Leave at null to just use defaults. Declaration public string EffectsId Field Value Type Description String ReactType Determines whether player is allowed to proceed with their pressing of the specified Hit Object. Declaration public ReactType ReactType Field Value Type Description ReactType Properties Default Default HitObjectReaction will allow Hit Object to proceed with being clicked on, and use default visual and sound effects upon being hit. Declaration public static readonly HitObjectReaction Default { get; } Property Value Type Description HitObjectReaction Remarks This is no guarantee that the Hit Object is collected, as that is still subject to the timing window and pressing in proper sequence."
  },
  "api/MouseDance.Runtime.HitObjectSet.html": {
    "href": "api/MouseDance.Runtime.HitObjectSet.html",
    "title": "Class HitObjectSet | MouseDance User Docs",
    "keywords": "Class HitObjectSet All prefabs needed by HitObjectManager to spawn Hit Objects and effects, grouped for easy reference. Inheritance Object Object ScriptableObject HitObjectSet LeftRightClickHitObjectSet MyHitObjectSet Namespace : MouseDance.Runtime Assembly : MouseDance.Runtime.dll Syntax [CreateAssetMenu(fileName = \"HitObjectSet\", menuName = \"MouseDance/HitObjectSet\")] public class HitObjectSet : ScriptableObject Fields HitCirclePrefab Declaration [Header(\"Hit Objects\")] [Tooltip(\"Master-copy of the Hit Circle prefab that will be spawned and pooled.\")] public HitCircle HitCirclePrefab Field Value Type Description HitCircle SdfCurvePrefab Declaration [Header(\"SDF Curve\")] [Tooltip(\"Master-copy of the SDF Curve prefab that will be spawned and pooled. Used by Sliders.\")] public SDFCurve SdfCurvePrefab Field Value Type Description SDFCurve SliderBallPrefab Declaration [Tooltip(\"Master-copy of the Slider Ball prefab. Used by Sliders.\")] public SliderBall SliderBallPrefab Field Value Type Description SliderBall SliderPrefab Declaration [Tooltip(\"Master-copy of the Slider prefab that will be spawned and pooled.\")] public Slider SliderPrefab Field Value Type Description Slider SliderTickPrefab Declaration [Tooltip(\"Master-copy of the Slider Tick prefab that will be spawned and pooled. Used by Sliders.\")] public SliderTick SliderTickPrefab Field Value Type Description SliderTick Methods GetHitCirclePrefab(Int32, Int32, Int32, HitCircle, Beatmap) Determine what Hit Circle Prefab should be given for this type of Hit Circle. Declaration public virtual (string, HitCircle) GetHitCirclePrefab(int idx, int comboCounter, int comboColourIdx, HitCircle hitCircle, Beatmap beatmap) Parameters Type Name Description Int32 idx Index position of the Hit Circle in the entire Beatmap. Starts at 0. Int32 comboCounter Number to be displayed on the Hit Circle. Int32 comboColourIdx What index of colour this Hit Circle is given. Starts at 0. OsuParsers.Beatmaps.Objects.HitCircle hitCircle Extra info about the Hit Circle. OsuParsers.Beatmaps.Beatmap beatmap Data on the entire Beatmap. Returns Type Description (T1, T2) < String , HitCircle > string: Unique Id for the prefab type given. HitCircle: The prefab master-copy to be instantiated. GetSliderBallPrefab(String) Declaration public virtual SliderBall GetSliderBallPrefab(string poolId) Parameters Type Name Description String poolId Returns Type Description SliderBall GetSliderPrefab(Int32, Int32, Int32, Slider, Beatmap) Determine what Slider Prefab should be given for this type of Slider. Declaration public virtual (string, Slider) GetSliderPrefab(int idx, int comboCounter, int comboColourIdx, Slider slider, Beatmap beatmap) Parameters Type Name Description Int32 idx Index position of the Slider in the entire Beatmap. Starts at 0. Int32 comboCounter Number to be displayed on the Slider. Int32 comboColourIdx What index of colour this Slider is given. Starts at 0. OsuParsers.Beatmaps.Objects.Slider slider Extra info about the Slider. OsuParsers.Beatmaps.Beatmap beatmap Data on the entire Beatmap. Returns Type Description (T1, T2) < String , Slider > string: Unique Id for the prefab type given. HitCircle: The prefab master-copy to be instantiated."
  },
  "api/MouseDance.Runtime.html": {
    "href": "api/MouseDance.Runtime.html",
    "title": "Namespace MouseDance.Runtime | MouseDance User Docs",
    "keywords": "Namespace MouseDance.Runtime All code needed for running MouseDance. Classes BeatmapAreaAdjuster Adds an optional position offset to the 4:3 area of the Beatmap, especially meant for use in portrait mode (i.e. mobile). BeatmapRunner Main class for starting a beatmap. BeatmapUtil Utility code for getting/deriving Beatmap properties. Effects Common entry point for any visual effects prefab instantiated by the HitObjectManager . GraphicsUtil Utility code for geometrical functions needed by Sliders, and graphical code needed by other parts of the game. HitCircle Graphical representation of a Hit Circle, displayed on the Beatmap Canvas by the HitObjectManager , and checked for mouse click by the BeatmapRunner . HitEffectsSet All prefabs needed by HitObjectManager to hit/miss effects, grouped for easy reference. HitObjectColours Combo Colours used by Hit Objects, and some simple tweaks with how they are applied. HitObjectManager Responsible for spawning and pooling Hit Objects and visual effects, plus playing any sound effects. HitObjectManagerSettings Values for tweaking Hit Objects HitObjectSet All prefabs needed by HitObjectManager to spawn Hit Objects and effects, grouped for easy reference. SDF2Line Draws two lines connected together, giving you three control points (start, mid, end). Rendered in SDF (signed distance field). SDF3Line Draws three lines connected together, giving you four control points (start, mid1, mid2, end). Rendered in SDF (signed distance field). SDFCurve Draws a curve with multiple points. Rendered in SDF (signed distance field). SDFLine Draws a straight line with two endpoints. Rendered in SDF (signed distance field). Slider Graphical representation of a Slider, displayed on the Beatmap Canvas by the HitObjectManager , and checked for mouse click by the BeatmapRunner . SliderBall Handles display and movement of a 3d ball that moves through a Slider's body. SliderTick Handles position and colour of a Slider Tick displayed on-screen. SoundEffectSet All AudioClips needed by HitObjectManager for hit/miss sound effects, grouped for easy reference. Util Miscellaneous utility code. Structs Gradient Simple struct holding two Color32 that represents start and end of gradient. Used by SDFCurve . HitEffectsSet.CustomVisualEffect Struct for specifying custom visual effects prefabs, identified by a string ID. Used for custom rules in a AllowCollect(IHitObject, IReadOnlyList<IHitObject>) . HitObjectReaction How you want a Hit Object to react to being clicked on. SoundEffectSet.CustomSoundEffect Struct for specifying custom sound effects, identified by a string ID. Used for custom rules in a AllowCollect(IHitObject, IReadOnlyList<IHitObject>) . Interfaces IBeatmapResults Provides information about the game that just ended. Used in IBeatmapEnd . IBeatmapRunner Used by Hit Objects to report when they are pressed (for adding score). IHitObject Read-only access to a Hit Object. Used for callback events. IHitObjectWithEvents Common properties among Hit Objects. Used so BeatmapRunner can handle Hit Objects regardless of what type they are. ISlider Used by the SliderBall to notify the Slider its rolling through of events. ISliderBall Properties of a Slider Ball that is exposed to a Slider . Enums LayerSpawnType ReactType How a Hit Object will react when pressed/clicked. SliderReachType Used to differentiate when the Slider Ball has reached the tail-end of the Slider, or the head of the Slider (moving in reverse)."
  },
  "api/MouseDance.Runtime.IBeatmapResults.html": {
    "href": "api/MouseDance.Runtime.IBeatmapResults.html",
    "title": "Interface IBeatmapResults | MouseDance User Docs",
    "keywords": "Interface IBeatmapResults Provides information about the game that just ended. Used in IBeatmapEnd . Namespace : MouseDance.Runtime Assembly : MouseDance.Runtime.dll Syntax public interface IBeatmapResults Properties HitObjects Read-only list of all hit objects used in the song's beatmap. Declaration IReadOnlyList<HitObject> HitObjects { get; } Property Value Type Description IReadOnlyList < OsuParsers.Beatmaps.Objects.HitObject > PlayerWin Did the player win? Declaration bool PlayerWin { get; } Property Value Type Description Boolean Score Player's current score. Declaration long Score { get; } Property Value Type Description Int64 Methods GetHitAccuracy(Int32) How close to the Hit Object's time did the player get when they pressed on a Hit Object. Declaration float GetHitAccuracy(int hitObjectIdx) Parameters Type Name Description Int32 hitObjectIdx Index of the Hit Object we are checking. Returns Type Description Single Normalized value indicating if user pressed Hit Object within correct time window. -1.0 to +1.0 is a hit. Any value outside that (lesser than -1.0 or greater than +1.0) means miss (negative for too early, positive for too late). 0.0 means user pressed exactly at Hit Object time. GetSliderPercentComplete(Int32) How many Slider Parts did user collect for the given Slider (in percentage)? Declaration float GetSliderPercentComplete(int sliderIdx) Parameters Type Name Description Int32 sliderIdx Index of the Slider we are checking. Returns Type Description Single Value within 0.0 to 1.0. 1.0 means 100% all collected. 0.5 means 50%, etc. -1 if the Slider was missed or if index specified is not for a Slider at all. WasHit(Int32) Did the player successfully press the hit object with the specified index? Index value corresponds to the list in HitObjects . Declaration bool WasHit(int hitObjectIdx) Parameters Type Name Description Int32 hitObjectIdx Index of the Hit Object we are checking. Returns Type Description Boolean"
  },
  "api/MouseDance.Runtime.IBeatmapRunner.html": {
    "href": "api/MouseDance.Runtime.IBeatmapRunner.html",
    "title": "Interface IBeatmapRunner | MouseDance User Docs",
    "keywords": "Interface IBeatmapRunner Used by Hit Objects to report when they are pressed (for adding score). Namespace : MouseDance.Runtime Assembly : MouseDance.Runtime.dll Syntax public interface IBeatmapRunner Methods CanCollectSliderPart(IHitObject) Called by Slider to check if we can proceed with collecting a Slider part. Declaration bool CanCollectSliderPart(IHitObject slider) Parameters Type Name Description IHitObject slider Returns Type Description Boolean True if we allow the Slider to collect the Slider part. OnUserFinishedSlider(IHitObjectWithEvents, Int32, Int32, Int32, Boolean) Called by Slider to let the BeatmapRunner know that the Slider has finished while user has their mouse down on it at that time. This is for letting the BeatmapRunner add score and to tally that the Slider was successfully collected. Declaration void OnUserFinishedSlider(IHitObjectWithEvents slider, int headScore, int collected, int total, bool pressWasEverReleased) Parameters Type Name Description IHitObjectWithEvents slider Slider that was finished. Int32 headScore What score the player got when they pressed on the Slider's head. Int32 collected How many parts of the Slider was pressed (head, ticks, and tail). Int32 total Total number of parts the Slider has (head, ticks, and tail). Boolean pressWasEverReleased Even if player has their mouse down right now, did player ever release their press of the button throughout the Slider? OnUserPressedHitCircle(IHitObjectWithEvents) Called by OnPressed(Int32) to let BeatmapRunner know that the user pressed on the HitCircle so it can tally and add to the score. Simultaneously, this also lets the Hit Circle know if user pressed within correct time window and how much score was received for it. Declaration (float, int) OnUserPressedHitCircle(IHitObjectWithEvents hitCircle) Parameters Type Name Description IHitObjectWithEvents hitCircle Hit Circle that was pressed. Returns Type Description (T1, T2) < Single , Int32 > Single: Normalized value indicating if user pressed within correct time window. -1.0 to +1.0 is a hit. Any value outside that (lesser than -1.0 or greater than +1.0) means miss (negative for too early, positive for too late). 0.0 means user pressed exactly at hit circle's time. int: score given for this particular pressed hit circle OnUserPressedSliderHead(Int32) Called by OnPressed(Int32) when user pressed the head (aka Start Cap) of a Slider. This is used to let the Slider know if user pressed within the correct time window, and what the equivalent score would be for that head press. Declaration (float, int) OnUserPressedSliderHead(int idx) Parameters Type Name Description Int32 idx Index of the Slider that was pressed. Returns Type Description (T1, T2) < Single , Int32 > Single: Normalized value indicating if user pressed slider's head within correct time window. -1 to +1 is a hit. Any value outside that (lesser than -1 or greater than +1) means miss (negative for too early, positive for too late). 0 means user pressed exactly at slider head's hit time. int: Equivalent score for pressing the Slider head. The score value here is not added to the player's score, but is calculated to let you know if the user did a perfect press or not."
  },
  "api/MouseDance.Runtime.IHitObject.html": {
    "href": "api/MouseDance.Runtime.IHitObject.html",
    "title": "Interface IHitObject | MouseDance User Docs",
    "keywords": "Interface IHitObject Read-only access to a Hit Object. Used for callback events. Namespace : MouseDance.Runtime Assembly : MouseDance.Runtime.dll Syntax public interface IHitObject Properties Colour Colour that this Hit Object is in. Used by visual effects so that their colour matches the Hit Object's colour. Declaration Color Colour { get; } Property Value Type Description Color ComboColourIndex The index of the colour used by this Hit Object. This can be used to identify or differentiate this Hit Object from others that are using a different colour. Declaration int ComboColourIndex { get; } Property Value Type Description Int32 ComboCounter The number displayed on this Hit Object. Declaration int ComboCounter { get; } Property Value Type Description Int32 EffectsPos When this Hit Object is pressed or missed, this is the position where the visual effects should spawn in. Declaration Vector3 EffectsPos { get; } Property Value Type Description Vector3 An (x, y, z) position Remarks This is an (x, y, z) position, though the z value is 0 and can be ignored. The only reason why this is a Vector3 and not a Vector2 is so that this value can be easily assigned to a Transform 's position . Index Index position of this Hit Object in the entire Beatmap. Starts at 0. Declaration int Index { get; } Property Value Type Description Int32 IsEnabled Informs the BeatmapRunner whether it should consider this Hit Object as hittable or not. Disabled Hit Objects are \"despawned\" and are back into the pool and therefore should not be used. Declaration bool IsEnabled { get; } Property Value Type Description Boolean True: This Hit Object is \"enabled\", currently being used and is on-screen. False: This Hit Object is considered to be \"disabled\", currently hidden and not in-use (but is ready to be re-used). PoolId Which pool of prefabs this Hit Object prefab will belong to. Important once it's time to despawn this Hit Object. Declaration string PoolId { get; } Property Value Type Description String Pressed Whether this Hit Object has been pressed already. Declaration bool Pressed { get; } Property Value Type Description Boolean True: Hit Object has already been pressed. False: This Hit Object is yet to be pressed. RequiresHold Does this Hit Object need to be pressed for a long time? Declaration bool RequiresHold { get; } Property Value Type Description Boolean"
  },
  "api/MouseDance.Runtime.IHitObjectWithEvents.html": {
    "href": "api/MouseDance.Runtime.IHitObjectWithEvents.html",
    "title": "Interface IHitObjectWithEvents | MouseDance User Docs",
    "keywords": "Interface IHitObjectWithEvents Common properties among Hit Objects. Used so BeatmapRunner can handle Hit Objects regardless of what type they are. Inherited Members IHitObject.IsEnabled IHitObject.EffectsPos IHitObject.PoolId IHitObject.Index IHitObject.ComboCounter IHitObject.Pressed IHitObject.ComboColourIndex IHitObject.Colour IHitObject.RequiresHold Namespace : MouseDance.Runtime Assembly : MouseDance.Runtime.dll Syntax public interface IHitObjectWithEvents : IHitObject Methods OnPressed(Int32) Notifies the Hit Object that it's been pressed by the player. Declaration void OnPressed(int idxThatNeedsToBePressed) Parameters Type Name Description Int32 idxThatNeedsToBePressed The current Hit Object index that should be pressed right now. If this doesn't match the Hit Object's index, then the player clicked out-of-sequence. OnReleased() Notifies the Hit Object that the player released their press on this Hit Object. Declaration void OnReleased() Resize(Single, Single) Resize this currently displayed Hit Object. Declaration void Resize(float radius, float radiusMultiplier) Parameters Type Name Description Single radius New size of Hit Object in pixel radius. Single radiusMultiplier Multiplier to the size coming from CircleRadiusMultiplier ."
  },
  "api/MouseDance.Runtime.ISlider.html": {
    "href": "api/MouseDance.Runtime.ISlider.html",
    "title": "Interface ISlider | MouseDance User Docs",
    "keywords": "Interface ISlider Used by the SliderBall to notify the Slider its rolling through of events. Inherited Members IHitObjectWithEvents.OnPressed(Int32) IHitObjectWithEvents.OnReleased() IHitObjectWithEvents.Resize(Single, Single) IHitObject.IsEnabled IHitObject.EffectsPos IHitObject.PoolId IHitObject.Index IHitObject.ComboCounter IHitObject.Pressed IHitObject.ComboColourIndex IHitObject.Colour IHitObject.RequiresHold Namespace : MouseDance.Runtime Assembly : MouseDance.Runtime.dll Syntax public interface ISlider : IHitObjectWithEvents, IHitObject Methods OnBallReachedPositionInPath(Int32, Int32, Boolean, Single) Called by the SliderBall to notify this Slider of its progress rolling. Declaration void OnBallReachedPositionInPath(int pathIdx, int numberOfTimes, bool forwardDirection, float ballDistanceToMouse) Parameters Type Name Description Int32 pathIdx The position that the ball has reached. Int32 numberOfTimes Number of times left. 1 means this is the final movement. Boolean forwardDirection Whether we are moving forward (from head to tail) or reverse (from tail to head). Single ballDistanceToMouse Current distance of mouse cursor to ball at the moment. OnPressedBody() Called by the BeatmapRunner to notify this Slider that the player clicked on the SliderBall while it's already in-the-process of moving through this Slider. Declaration void OnPressedBody() OnReachedEnd() Called by the BeatmapRunner to notify this Slider that its End Time has been reached. Declaration void OnReachedEnd()"
  },
  "api/MouseDance.Runtime.ISliderBall.html": {
    "href": "api/MouseDance.Runtime.ISliderBall.html",
    "title": "Interface ISliderBall | MouseDance User Docs",
    "keywords": "Interface ISliderBall Properties of a Slider Ball that is exposed to a Slider . Namespace : MouseDance.Runtime Assembly : MouseDance.Runtime.dll Syntax public interface ISliderBall Properties DistanceToMouse Mouse cursor's distance to the Ball. Declaration float DistanceToMouse { get; } Property Value Type Description Single IsMoving If the Ball has already started moving or not. Declaration bool IsMoving { get; } Property Value Type Description Boolean Slider The Slider that this Ball is rolling through. Declaration ISlider Slider { get; } Property Value Type Description ISlider Methods Move(ISlider, Int32, Boolean, Single, Double, Int32, Vector2, List<Vector3>, Color, Boolean) Start moving the Slider Ball through the specified Slider. Declaration void Move(ISlider slider, int comboCounter, bool showNumber, float radius, double ballSpeed, int numberOfTimes, Vector2 initialPos, List<Vector3> path, Color colour, bool smoothenOrientation) Parameters Type Name Description ISlider slider The Slider that the Ball will now move through. Int32 comboCounter The number displayed by the Slider. Use this if your Slider Ball also shows that number. Boolean showNumber Whether the Slider Ball should also show the number. Single radius How big the ball should be. Double ballSpeed How fast the ball should be. Int32 numberOfTimes How many times the Ball should move through the Slider. Vector2 initialPos Starting position of the Slider. List < Vector3 > path Local-space positions of each point in the Slider's line. Color colour Colour of that the Ball should be in. Boolean smoothenOrientation Whether the change of the Ball's facing direction should be smoothened out. Resize(Single) Resize the ball, meant to be used when the ball is currently shown. Declaration void Resize(float radius) Parameters Type Name Description Single radius How big the ball should be."
  },
  "api/MouseDance.Runtime.LayerSpawnType.html": {
    "href": "api/MouseDance.Runtime.LayerSpawnType.html",
    "title": "Enum LayerSpawnType | MouseDance User Docs",
    "keywords": "Enum LayerSpawnType Namespace : MouseDance.Runtime Assembly : MouseDance.Runtime.dll Syntax public enum LayerSpawnType Fields Name Description UseLayerOfParentContainer UseSpecificLayer"
  },
  "api/MouseDance.Runtime.ReactType.html": {
    "href": "api/MouseDance.Runtime.ReactType.html",
    "title": "Enum ReactType | MouseDance User Docs",
    "keywords": "Enum ReactType How a Hit Object will react when pressed/clicked. Namespace : MouseDance.Runtime Assembly : MouseDance.Runtime.dll Syntax public enum ReactType Fields Name Description FadeOut Hit Circle will not be collected and is faded-out. This count as a miss (plays appropriate sound effect). Since the Hit Object will disappear, player will no longer be able to attempt hitting it again. For Sliders, this will do nothing. None Hit Object will not be collected. No visual and sound effects are played. It will still stay on screen, allowing the player to retry. Proceed Allow the Hit Object to be pressed. This is no guarantee that the Hit Object is collected, as that is still subject to the timing window and pressing in proper sequence. Shake Hit Circle will not be collected and do a shaking animation. It will still stay on screen, allowing the player to retry. For Sliders, this will do nothing."
  },
  "api/MouseDance.Runtime.SDF2Line.html": {
    "href": "api/MouseDance.Runtime.SDF2Line.html",
    "title": "Class SDF2Line | MouseDance User Docs",
    "keywords": "Class SDF2Line Draws two lines connected together, giving you three control points (start, mid, end). Rendered in SDF (signed distance field). Inheritance Object Object Component Behaviour MonoBehaviour SDF2Line Namespace : MouseDance.Runtime Assembly : MouseDance.Runtime.dll Syntax public class SDF2Line : MonoBehaviour Methods Init(Camera, RectTransform, RectTransform) Declaration public void Init(Camera viewCamera, RectTransform canvasTransform, RectTransform screenAdjust) Parameters Type Name Description Camera viewCamera RectTransform canvasTransform RectTransform screenAdjust SetColour(Color) Declaration public void SetColour(Color colour) Parameters Type Name Description Color colour SetFirstLine(Vector2, Vector2) Declaration public void SetFirstLine(Vector2 start, Vector2 mid1) Parameters Type Name Description Vector2 start Vector2 mid1 SetOpacity(Single, Boolean) Declaration public void SetOpacity(float alpha, bool applyImmediately = true) Parameters Type Name Description Single alpha Boolean applyImmediately SetSecondLine(Vector2, Vector2) Declaration public void SetSecondLine(Vector2 mid1, Vector2 end) Parameters Type Name Description Vector2 mid1 Vector2 end Show(Vector2, Vector2, Vector2) Declaration public void Show(Vector2 start, Vector2 mid1, Vector2 end) Parameters Type Name Description Vector2 start Vector2 mid1 Vector2 end Extension Methods Util.SetLayerDeep(Component, LayerMask) Util.SetLayerDeep(Component, Int32) Util.SetLayerDeep(Component, LayerMask, Stack<Transform>)"
  },
  "api/MouseDance.Runtime.SDF3Line.html": {
    "href": "api/MouseDance.Runtime.SDF3Line.html",
    "title": "Class SDF3Line | MouseDance User Docs",
    "keywords": "Class SDF3Line Draws three lines connected together, giving you four control points (start, mid1, mid2, end). Rendered in SDF (signed distance field). Inheritance Object Object Component Behaviour MonoBehaviour SDF3Line Namespace : MouseDance.Runtime Assembly : MouseDance.Runtime.dll Syntax public class SDF3Line : MonoBehaviour Methods Init(Camera, RectTransform, RectTransform) Declaration public void Init(Camera viewCamera, RectTransform canvasTransform, RectTransform screenAdjust) Parameters Type Name Description Camera viewCamera RectTransform canvasTransform RectTransform screenAdjust SetColour(Color) Declaration public void SetColour(Color colour) Parameters Type Name Description Color colour SetFirstLine(Vector2, Vector2) Declaration public void SetFirstLine(Vector2 start, Vector2 mid1) Parameters Type Name Description Vector2 start Vector2 mid1 SetOpacity(Single, Boolean) Declaration public void SetOpacity(float alpha, bool applyImmediately = true) Parameters Type Name Description Single alpha Boolean applyImmediately SetSecondLine(Vector2, Vector2) Declaration public void SetSecondLine(Vector2 mid1, Vector2 mid2) Parameters Type Name Description Vector2 mid1 Vector2 mid2 SetThirdLine(Vector2, Vector2) Declaration public void SetThirdLine(Vector2 mid2, Vector2 end) Parameters Type Name Description Vector2 mid2 Vector2 end Show(Vector2, Vector2, Vector2, Vector2) Declaration public void Show(Vector2 start, Vector2 mid1, Vector2 mid2, Vector2 end) Parameters Type Name Description Vector2 start Vector2 mid1 Vector2 mid2 Vector2 end Extension Methods Util.SetLayerDeep(Component, LayerMask) Util.SetLayerDeep(Component, Int32) Util.SetLayerDeep(Component, LayerMask, Stack<Transform>)"
  },
  "api/MouseDance.Runtime.SDFCurve.html": {
    "href": "api/MouseDance.Runtime.SDFCurve.html",
    "title": "Class SDFCurve | MouseDance User Docs",
    "keywords": "Class SDFCurve Draws a curve with multiple points. Rendered in SDF (signed distance field). Inheritance Object Object Component Behaviour MonoBehaviour SDFCurve Namespace : MouseDance.Runtime Assembly : MouseDance.Runtime.dll Syntax public class SDFCurve : MonoBehaviour Methods Init(Camera, RectTransform, RectTransform) Assign the dependencies that SDFCurve needs. Declaration public void Init(Camera viewCamera, RectTransform canvasTransform, RectTransform screenAdjust) Parameters Type Name Description Camera viewCamera Needed to get the camera's orthographic size (SDFCurve works best when displayed by a camera in orthographic mode). The orthographic size is needed due to how the SDFCurve is rendered, it affects how the SDFCurve is positioned. RectTransform canvasTransform Transform component of the Unity UI Canvas that is displaying this SDFCurve. Needed because it should affect how the SDFCurve is positioned and scaled. RectTransform screenAdjust Used for additional offset on how the SDFCurve is positioned. Reposition() Declaration public void Reposition() Reposition(Slider, Boolean) If Slider position has changed, this updates the currently shown SDF curve to that new position. Declaration public void Reposition(Slider slider, bool applyImmediately) Parameters Type Name Description OsuParsers.Beatmaps.Objects.Slider slider Where position comes from. Boolean applyImmediately Apply the MaterialPropertyBlock now. Set to false if you plan to do it later. Resize(Single, Single, Single, Boolean) Change line thickness of the curve. Declaration public void Resize(float radius, float globalSizeMultiplier, float sliderSizeMultiplier, bool applyImmediately) Parameters Type Name Description Single radius Thickness of the line. Since the line has circular caps, we express line thickness as a radius. Single globalSizeMultiplier Multiplier to the size coming from CircleRadiusMultiplier . Single sliderSizeMultiplier Multiplier to the size coming from MouseDance.Runtime.Slider._sliderThicknessMultiplier . Boolean applyImmediately Apply the MaterialPropertyBlock now. Set to false if you plan to do it later. SetOpacity(Single) Set the alpha of the entire curve. Use this for fading-in or fading-out. Declaration public void SetOpacity(float alpha) Parameters Type Name Description Single alpha Value from 0.0 to 1.0. Show(Slider, Single, Single, Single, Gradient, Color) Show the SDF Curve with the specified properties. Points of the curve will come from the Slider data. Declaration public void Show(Slider slider, float radius, float globalSizeMultiplier, float sliderSizeMultiplier, Gradient colour, Color borderColour) Parameters Type Name Description OsuParsers.Beatmaps.Objects.Slider slider Where point data will come from. Single radius Thickness of the line. Since the line has circular caps, we express line thickness as a radius. Single globalSizeMultiplier Multiplier to the size coming from CircleRadiusMultiplier . Single sliderSizeMultiplier Multiplier to the size coming from MouseDance.Runtime.Slider._sliderThicknessMultiplier . Gradient colour Colour to apply to the body of the curve. This is a gradient so we're blending between two colors. Color borderColour Colour to apply to the borders of the curve. Show(Slider, Single, Single, Single, Color, Color, Color) Show the SDF Curve with the specified properties. Points of the curve will come from the Slider data. Declaration public void Show(Slider slider, float radius, float globalSizeMultiplier, float sliderSizeMultiplier, Color gradientInnerColour, Color gradientOuterColour, Color borderColour) Parameters Type Name Description OsuParsers.Beatmaps.Objects.Slider slider Where point data will come from. Single radius Thickness of the line. Since the line has circular caps, we express line thickness as a radius. Single globalSizeMultiplier Multiplier to the size coming from CircleRadiusMultiplier . Single sliderSizeMultiplier Multiplier to the size coming from MouseDance.Runtime.Slider._sliderThicknessMultiplier . Color gradientInnerColour Color of the line starting from the center. Color gradientOuterColour Color of the line at the outer edges. Color borderColour Colour to apply to the borders of the curve. Extension Methods Util.SetLayerDeep(Component, LayerMask) Util.SetLayerDeep(Component, Int32) Util.SetLayerDeep(Component, LayerMask, Stack<Transform>)"
  },
  "api/MouseDance.Runtime.SDFLine.html": {
    "href": "api/MouseDance.Runtime.SDFLine.html",
    "title": "Class SDFLine | MouseDance User Docs",
    "keywords": "Class SDFLine Draws a straight line with two endpoints. Rendered in SDF (signed distance field). Inheritance Object Object Component Behaviour MonoBehaviour SDFLine Namespace : MouseDance.Runtime Assembly : MouseDance.Runtime.dll Syntax public class SDFLine : MonoBehaviour Methods FastShow(Vector2, Vector2) Declaration public void FastShow(Vector2 start, Vector2 end) Parameters Type Name Description Vector2 start Vector2 end Init(Camera, RectTransform, RectTransform) Declaration public void Init(Camera viewCamera, RectTransform canvasTransform, RectTransform screenAdjust) Parameters Type Name Description Camera viewCamera RectTransform canvasTransform RectTransform screenAdjust SetColour(Color) Declaration public void SetColour(Color colour) Parameters Type Name Description Color colour SetOpacity(Single) Declaration public void SetOpacity(float alpha) Parameters Type Name Description Single alpha Show(Vector2, Vector2) Declaration public void Show(Vector2 start, Vector2 end) Parameters Type Name Description Vector2 start Vector2 end Extension Methods Util.SetLayerDeep(Component, LayerMask) Util.SetLayerDeep(Component, Int32) Util.SetLayerDeep(Component, LayerMask, Stack<Transform>)"
  },
  "api/MouseDance.Runtime.Slider.html": {
    "href": "api/MouseDance.Runtime.Slider.html",
    "title": "Class Slider | MouseDance User Docs",
    "keywords": "Class Slider Graphical representation of a Slider, displayed on the Beatmap Canvas by the HitObjectManager , and checked for mouse click by the BeatmapRunner . Inheritance Object Object Component Behaviour MonoBehaviour Slider Implements ISlider IHitObjectWithEvents IHitObject Namespace : MouseDance.Runtime Assembly : MouseDance.Runtime.dll Syntax public class Slider : MonoBehaviour, ISlider, IHitObjectWithEvents, IHitObject Remarks The Slider takes care of its own fading in and out. It makes use of an SDFCurve to show the curve. It directs the SliderBall to roll through it when the time comes. Hit and miss visual effects are handled by the HitObjectManager . Properties Colour Colour that this Slider is in. Used by visual effects so that their colour matches the Slider's colour. Declaration public Color Colour { get; } Property Value Type Description Color ComboColourIndex The index of the colour used by this Slider. This can be used to identify or differentiate this Slider from other Hit Objects that are using a different colour. Declaration public int ComboColourIndex { get; } Property Value Type Description Int32 ComboCounter The number displayed on this Slider. Declaration public int ComboCounter { get; } Property Value Type Description Int32 EffectsPos When this Hit Object is pressed or missed, this is the position where the visual effects should spawn in. For Sliders, this position is the Slider's tail-end. Declaration public Vector3 EffectsPos { get; } Property Value Type Description Vector3 An (x, y, z) position Remarks This is an (x, y, z) position, though the z value is 0 and can be ignored. The only reason why this is a Vector3 and not a Vector2 is so that this value can be easily assigned to a Transform 's position . Index Index position of this Slider in the entire Beatmap. Starts at 0. Declaration public int Index { get; } Property Value Type Description Int32 IsEnabled Informs the BeatmapRunner whether it should consider this Slider as hittable or not. Disabled Sliders are \"despawned\" and are back into the pool and therefore should not be used. Declaration public bool IsEnabled { get; } Property Value Type Description Boolean True: This Slider is \"enabled\", currently being used and is on-screen. False: This Slider is considered to be \"disabled\", currently hidden and not in-use (but is ready to be re-used). PoolId What pool of Slider prefabs this prefab belongs to. Important once it's time to despawn this Slider. Declaration public string PoolId { get; } Property Value Type Description String Pressed Whether this Slider has been pressed already. Declaration public bool Pressed { get; } Property Value Type Description Boolean True: Slider has already been pressed. False: This Slider is yet to be pressed. RequiresHold Does this Hit Object need to be pressed for a long time? For Sliders, this always returns true. Declaration public bool RequiresHold { get; } Property Value Type Description Boolean Methods Hide() Hide this Slider immediately (no fade out). Declaration public void Hide() IsNameMatch(String) Is specified name the kind of name assigned to Sliders? Declaration public static bool IsNameMatch(string name) Parameters Type Name Description String name Returns Type Description Boolean OnBallReachedPositionInPath(Int32, Int32, Boolean, Single) Called by the SliderBall to notify this Slider of its progress rolling through it. Declaration public void OnBallReachedPositionInPath(int pathIdx, int numberOfTimes, bool forwardDirection, float ballDistanceToMouse) Parameters Type Name Description Int32 pathIdx The position that the ball has reached. Int32 numberOfTimes Number of times left. 1 means this is the final movement. Boolean forwardDirection Whether we are moving forward (from head to tail) or reverse (from tail to head). Single ballDistanceToMouse How far away the mouse cursor is from the Slider Ball (in osu!pixels ) at the moment. This is important because a hit is only considered if the mouse cursor is near enough. OnPressed(Int32) Called by the BeatmapRunner to notify this Slider that its start cap (head) has been pressed by the player. Declaration public void OnPressed(int idxThatNeedsToBePressed) Parameters Type Name Description Int32 idxThatNeedsToBePressed The current Hit Object index that should be pressed right now. If this doesn't match the Slider's own Index , then the player clicked out-of-sequence. OnPressedBody() Called by the BeatmapRunner to notify this Slider that the player clicked on the SliderBall while it's already in-the-process of moving through this Slider. Declaration public void OnPressedBody() OnReachedEnd() Called by the BeatmapRunner to notify this Slider that its End Time has been reached. Declaration public void OnReachedEnd() OnReleased() Called by the BeatmapRunner to notify this Slider that the player released their press on it. Declaration public void OnReleased() Resize(Single, Single) Declaration public void Resize(float radius, float radiusMultiplier) Parameters Type Name Description Single radius Single radiusMultiplier Resize(Single, Single, Boolean) Resize this Slider with specified radius. Declaration public void Resize(float radius, float radiusMultiplier, bool applyToSdfCurve) Parameters Type Name Description Single radius The radius that will be used for the start and end caps, as well as the thickness of the slider body. Single radiusMultiplier Multiplier to the size coming from CircleRadiusMultiplier . Boolean applyToSdfCurve Apply resizing to the SDF Curve as well. Show(HitObjectManager, IBeatmapRunner, ISliderBall, String, Int32, Int32, Int32, Gradient, Color32, Color32, Color32, Boolean, Boolean, Double, Slider, Single, Single, Single, Single, Double, Double) Show this Slider with the specified position, colour, etc. This overload also initializes the Slider's reference to the HitObjectManager and BeatmapRunner , and is called for newly instantiated Sliders. Declaration public int Show(HitObjectManager manager, IBeatmapRunner beatmapRunner, ISliderBall ball, string poolId, int idx, int comboCounter, int comboColourIdx, Gradient colour, Color32 borderColour, Color32 repeatArrowColour, Color32 ballColour, bool applyColourToApproachCircles, bool showNumber, double beatLength, Slider slider, float positionScale, float radius, float radiusMultiplier, float approachRateDuration, double sliderMultiplier, double sliderTickRate) Parameters Type Name Description HitObjectManager manager Which HitObjectManager manages this Slider. Needed to allow this Slider to be despawned and moved back to pool for reusing, and for reporting when user has pressed the Slider right or wrong so it can play the proper sound/visual fx. IBeatmapRunner beatmapRunner Needed by the Slider so it can report to the game when player pressed that Slider's head. This also lets the Slider know if the player pressed too early or not. ISliderBall ball Slider needs to be able to tell the Slider Ball to roll through it when the time comes. String poolId Which pool of prefabs this Hit Circle will belong to. Int32 idx Numerical position of the Slider in the entire Beatmap. Int32 comboCounter The number that should be displayed in this Slider. Int32 comboColourIdx The index of the colour used by this Hit Object. This can be used to identify or differentiate this Hit Object from others using a different colour. Gradient colour Colour that this Slider should be in. Color32 borderColour Colour that this Slider's borders should be in. Color32 repeatArrowColour Colour that this Slider's repeat arrow should be in. Color32 ballColour Colour that the SliderBall should be in once it's rolling through this Slider. Boolean applyColourToApproachCircles Whether specified colour should also be applied to the Approach Circle. If false, Approach Circle will just be white. Boolean showNumber Whether to show the number on this Slider or not. Double beatLength How long one beat is, in milliseconds. This is needed because we will be putting Slider Ticks on each beat. OsuParsers.Beatmaps.Objects.Slider slider More data on the Slider. Single positionScale Single radius The radius that will be used for the start and end caps, as well as the thickness of the slider body. Based on the OsuParsers.Beatmaps.Sections.BeatmapDifficultySection.CircleSize . Single radiusMultiplier Multiplier to the size coming from CircleRadiusMultiplier . Single approachRateDuration How long it will take for the Approach Circle to do its shrinking animation. Double sliderMultiplier Controls ball speed. Double sliderTickRate How many Slider Ticks per beat. Default is 1 (1 Slider Tick per 1 beat). 0.5 means 1 Slider Tick per 2 beats. Returns Type Description Int32 Show(String, Int32, Int32, Int32, Gradient, Color32, Color32, Color32, Boolean, Boolean, Double, Slider, Single, Single, Single, Single, Double, Double) Show this Slider with the specified position, colour, etc. This is called on reused Sliders. Declaration public int Show(string poolId, int idx, int comboCounter, int comboColourIdx, Gradient colour, Color32 borderColour, Color32 repeatArrowColour, Color32 ballColour, bool applyColourToApproachCircles, bool showNumber, double beatLength, Slider slider, float positionScale, float radius, float radiusMultiplier, float approachRateDuration, double sliderMultiplier, double sliderTickRate) Parameters Type Name Description String poolId Which pool of prefabs this Hit Circle will belong to. Int32 idx Numerical position of the Slider in the entire Beatmap. Int32 comboCounter The number that should be displayed in this Slider. Int32 comboColourIdx The index of the colour used by this Hit Object. This can be used to identify or differentiate this Hit Object from others using a different colour. Gradient colour Colour that this Slider should be in. Color32 borderColour Colour that this Slider's borders should be in. Color32 repeatArrowColour Colour that this Slider's repeat arrow should be in. Color32 ballColour Colour that the SliderBall should be in once it's rolling through this Slider. Boolean applyColourToApproachCircles Whether specified colour should also be applied to the Approach Circle. If false, Approach Circle will just be white. Boolean showNumber Whether to show the number on this Slider or not. Double beatLength How long one beat is, in milliseconds. This is needed because we will be putting Slider Ticks on each beat. OsuParsers.Beatmaps.Objects.Slider slider More data on the Slider. Single positionScale Single radius The radius that will be used for the start and end caps, as well as the thickness of the slider body. Based on the OsuParsers.Beatmaps.Sections.BeatmapDifficultySection.CircleSize . Single radiusMultiplier Multiplier to the size coming from CircleRadiusMultiplier . Single approachRateDuration How long it will take for the Approach Circle to do its shrinking animation. Double sliderMultiplier Controls ball speed. Double sliderTickRate How many Slider Ticks per beat. Default is 1 (1 Slider Tick per 1 beat). 0.5 means 1 Slider Tick per 2 beats. Returns Type Description Int32 Update() Update method called by Unity every frame. This is used to update the Slider's animations (Approach Circle shrinking animation, fading in and out). Declaration public void Update() Implements ISlider IHitObjectWithEvents IHitObject Extension Methods Util.SetLayerDeep(Component, LayerMask) Util.SetLayerDeep(Component, Int32) Util.SetLayerDeep(Component, LayerMask, Stack<Transform>)"
  },
  "api/MouseDance.Runtime.SliderBall.html": {
    "href": "api/MouseDance.Runtime.SliderBall.html",
    "title": "Class SliderBall | MouseDance User Docs",
    "keywords": "Class SliderBall Handles display and movement of a 3d ball that moves through a Slider's body. Inheritance Object Object Component Behaviour MonoBehaviour SliderBall Implements ISliderBall Namespace : MouseDance.Runtime Assembly : MouseDance.Runtime.dll Syntax public class SliderBall : MonoBehaviour, ISliderBall Properties DistanceToMouse Declaration public float DistanceToMouse { get; } Property Value Type Description Single IsMoving If the Ball has already started moving or not. Declaration public bool IsMoving { get; } Property Value Type Description Boolean Slider The Slider that this Ball is rolling through. Needed so we can inform the Slider of our roll progress through OnBallReachedPositionInPath(Int32, Int32, Boolean, Single) Declaration public ISlider Slider { get; } Property Value Type Description ISlider Methods Hide() Immediately hide this Slider Ball (no fade-out). Declaration public void Hide() Move(ISlider, Int32, Boolean, Single, Double, Int32, Vector2, List<Vector3>, Color, Boolean) Start moving the Slider Ball through the specified Slider. Declaration public void Move(ISlider slider, int comboCounter, bool showNumber, float radius, double ballSpeed, int numberOfTimes, Vector2 initialPos, List<Vector3> path, Color colour, bool smoothenOrientation) Parameters Type Name Description ISlider slider The Slider that the Ball will now move through. Int32 comboCounter The number displayed by the Slider. Use this if your Slider Ball also shows that number. Boolean showNumber Whether the Slider Ball should also show the number. Single radius How big the ball should be. Double ballSpeed How fast the ball should be. Int32 numberOfTimes How many times the Ball should move through the Slider. Vector2 initialPos Starting position of the Slider. List < Vector3 > path Local-space positions of each point in the Slider's line. Color colour Colour of that the Ball should be in. Boolean smoothenOrientation Whether the change of the Ball's facing direction should be smoothened out. Resize(Single) Resize the ball, meant to be used when the ball is currently shown. Declaration public void Resize(float radius) Parameters Type Name Description Single radius How big the ball should be. SetInput(IBeatmapInput) Needed for getting the mouse cursor position. Declaration public void SetInput(IBeatmapInput beatmapInput) Parameters Type Name Description IBeatmapInput beatmapInput Needed for properly checking mouse cursor position. SetViewCamera(Camera) Needed for figuring out the distance between this Slider Ball and the mouse cursor (or touch input, for mobile). Declaration public void SetViewCamera(Camera newViewCam) Parameters Type Name Description Camera newViewCam The camera that will be used for figuring out the distance between this ball and mouse cursor. Implements ISliderBall Extension Methods Util.SetLayerDeep(Component, LayerMask) Util.SetLayerDeep(Component, Int32) Util.SetLayerDeep(Component, LayerMask, Stack<Transform>)"
  },
  "api/MouseDance.Runtime.SliderReachType.html": {
    "href": "api/MouseDance.Runtime.SliderReachType.html",
    "title": "Enum SliderReachType | MouseDance User Docs",
    "keywords": "Enum SliderReachType Used to differentiate when the Slider Ball has reached the tail-end of the Slider, or the head of the Slider (moving in reverse). Namespace : MouseDance.Runtime Assembly : MouseDance.Runtime.dll Syntax public enum SliderReachType Fields Name Description Head Ball reached the head of the Slider (i.e. it was moving in reverse). Tail Ball reached the tail-end of the Slider."
  },
  "api/MouseDance.Runtime.SliderTick.html": {
    "href": "api/MouseDance.Runtime.SliderTick.html",
    "title": "Class SliderTick | MouseDance User Docs",
    "keywords": "Class SliderTick Handles position and colour of a Slider Tick displayed on-screen. Inheritance Object Object Component Behaviour MonoBehaviour SliderTick Namespace : MouseDance.Runtime Assembly : MouseDance.Runtime.dll Syntax public class SliderTick : MonoBehaviour Methods Show(Vector2, Color32) Show the Slider Tick in a specific position and colour. Declaration public void Show(Vector2 pos, Color32 colour) Parameters Type Name Description Vector2 pos Color32 colour Extension Methods Util.SetLayerDeep(Component, LayerMask) Util.SetLayerDeep(Component, Int32) Util.SetLayerDeep(Component, LayerMask, Stack<Transform>)"
  },
  "api/MouseDance.Runtime.SoundEffectSet.CustomSoundEffect.html": {
    "href": "api/MouseDance.Runtime.SoundEffectSet.CustomSoundEffect.html",
    "title": "Struct SoundEffectSet.CustomSoundEffect | MouseDance User Docs",
    "keywords": "Struct SoundEffectSet.CustomSoundEffect Struct for specifying custom sound effects, identified by a string ID. Used for custom rules in a AllowCollect(IHitObject, IReadOnlyList<IHitObject>) . Namespace : MouseDance.Runtime Assembly : MouseDance.Runtime.dll Syntax [Serializable] public struct CustomSoundEffect Fields ID Declaration public string ID Field Value Type Description String Sound Declaration public AudioClip Sound Field Value Type Description AudioClip"
  },
  "api/MouseDance.Runtime.SoundEffectSet.html": {
    "href": "api/MouseDance.Runtime.SoundEffectSet.html",
    "title": "Class SoundEffectSet | MouseDance User Docs",
    "keywords": "Class SoundEffectSet All AudioClips needed by HitObjectManager for hit/miss sound effects, grouped for easy reference. Inheritance Object Object ScriptableObject SoundEffectSet Namespace : MouseDance.Runtime Assembly : MouseDance.Runtime.dll Syntax [CreateAssetMenu(fileName = \"SoundEffectSet\", menuName = \"MouseDance/SoundEffectSet\")] public class SoundEffectSet : ScriptableObject, ISerializationCallbackReceiver Fields _CustomSoundEffect Declaration [Space(20F)] [Tooltip(\"Custom sounds meant for use in custom rules.\")] public List<SoundEffectSet.CustomSoundEffect> _CustomSoundEffect Field Value Type Description List < SoundEffectSet.CustomSoundEffect > CustomSound Declaration public Dictionary<string, AudioClip> CustomSound Field Value Type Description Dictionary < String , AudioClip > DefaultHitSound Declaration [Header(\"Hit Sounds\")] [Tooltip(\"Hit sound meant for when user successfully pressed a hit object.\")] public AudioClip DefaultHitSound Field Value Type Description AudioClip DefaultMissSound Declaration [Tooltip(\"Error sound meant for when user was not able to press a hit object at all. This plays as the hit object disappears.\")] public AudioClip DefaultMissSound Field Value Type Description AudioClip DefaultOutOfSequenceSound Declaration [Tooltip(\"Error sound meant for when user tries to press a hit object that isn't supposed to be hit yet (e.g. user is trying to press Hit Circle 2 when Hit Circle 1 hasn't been pressed yet).\")] public AudioClip DefaultOutOfSequenceSound Field Value Type Description AudioClip DefaultSliderHeadHitSound Declaration [Tooltip(\"Hit sound meant for when user successfully pressed the head of a Slider.\")] public AudioClip DefaultSliderHeadHitSound Field Value Type Description AudioClip DefaultSliderReachedHeadHitSound Declaration [Tooltip(\"Hit sound meant for when the ball reaches the head of a Slider (when moving in reverse) while user has their mouse down on it.\")] public AudioClip DefaultSliderReachedHeadHitSound Field Value Type Description AudioClip DefaultSliderReachedTailHitSound Declaration [Tooltip(\"Hit sound meant for when the ball reaches the tail of a Slider while user has their mouse down on it.\")] public AudioClip DefaultSliderReachedTailHitSound Field Value Type Description AudioClip DefaultSliderTickHitSound Declaration [Tooltip(\"Hit sound meant for when user successfully passed through a Slider Tick object.\")] public AudioClip DefaultSliderTickHitSound Field Value Type Description AudioClip DefaultTooEarlySound Declaration [Header(\"Error Sounds\")] [Tooltip(\"Error sound meant for when user tries to press a hit object that was supposed to be hit, but it's not yet time to hit it.\")] public AudioClip DefaultTooEarlySound Field Value Type Description AudioClip DefaultTooLateSound Declaration [Tooltip(\"Error sound meant for when user tries to press a hit object that was supposed to be hit, but whose time is already up.\")] public AudioClip DefaultTooLateSound Field Value Type Description AudioClip Methods OnAfterDeserialize() Declaration public void OnAfterDeserialize() OnBeforeSerialize() Declaration public void OnBeforeSerialize()"
  },
  "api/MouseDance.Runtime.Util.html": {
    "href": "api/MouseDance.Runtime.Util.html",
    "title": "Class Util | MouseDance User Docs",
    "keywords": "Class Util Miscellaneous utility code. Inheritance Object Util Namespace : MouseDance.Runtime Assembly : MouseDance.Runtime.dll Syntax public static class Util Methods FindBitPosition(Int32) Given an int that represents a bitmask, find the position of the first bit that is set to 1. Declaration public static int FindBitPosition(this int n) Parameters Type Name Description Int32 n int value that we're checking. Returns Type Description Int32 A value from 0 to 31. Remarks If specified int is not power-of-two, we'll end up returning the position of the first bit that is set, ignoring the rest. SetLayerDeep(Component, Int32) Change layer of GameObject, plus all of its children. Uses stack instead of recursive calls. Declaration public static void SetLayerDeep(this Component c, int layer) Parameters Type Name Description Component c The component whose GameObject we'll be editing. Int32 layer The 0 to 31 value of the layer. SetLayerDeep(Component, LayerMask) Change layer of GameObject, plus all of its children. Uses stack instead of recursive calls. Declaration public static void SetLayerDeep(this Component c, LayerMask layer) Parameters Type Name Description Component c The component whose GameObject we'll be editing. LayerMask layer Uses first layer toggled in this LayerMask. SetLayerDeep(Component, LayerMask, Stack<Transform>) Change layer of GameObject, plus all of its children. Uses stack instead of recursive calls. Declaration public static void SetLayerDeep(this Component c, LayerMask layer, Stack<Transform> stack) Parameters Type Name Description Component c The component whose GameObject we'll be editing. LayerMask layer Uses first layer toggled in this LayerMask. Stack < Transform > stack The stack to use as the buffer for traversing all children of the GameObject. SetLayerDeep(Transform, Int32, Stack<Transform>) Change layer of GameObject, plus all of its children. Uses stack instead of recursive calls. Declaration public static void SetLayerDeep(this Transform t, int layer, Stack<Transform> stack) Parameters Type Name Description Transform t The Transform whose GameObject we'll be editing. Int32 layer The 0 to 31 value of the layer. Stack < Transform > stack The stack to use as the buffer for traversing all children of the GameObject."
  },
  "index.html": {
    "href": "index.html",
    "title": "MouseDance User Documentation | MouseDance User Docs",
    "keywords": "MouseDance User Documentation MouseDance is a Unity plugin that loads .osu files and allows you to play Osu! style rhythm games inside Unity. This allows you to use the Osu! Beatmap Editor to create and playtest your own .osu files, then import them into Unity to be used in your actual game. .screenshot-container { max-width: 1280px; width: 90%; position: relative; transform: translate(-50%,0%); left: 50%; overflow: hidden; border: 6px solid #ffffff; border-radius: 4px; background-color: #2d2d2d; box-shadow: 10px 25px 30px rgba(0,0,0,0.3); margin-top: 38px; margin-bottom: 31px; } .screenshot-wrapper { width: 100%; display: flex; } .screenshot-wrapper > * { width: 100%; max-width: 100%; position: absolute; top: 0; left: 0; opacity: 0.0; animation: 20s crossfade-5-slides infinite linear; } .screenshot-wrapper > *:nth-child(1) {animation-delay: 0s} .screenshot-wrapper > *:nth-child(2) {animation-delay: 4s} .screenshot-wrapper > *:nth-child(3) {animation-delay: 8s} .screenshot-wrapper > *:nth-child(4) {animation-delay: 12s} .screenshot-wrapper > *:nth-child(5) {animation-delay: 16s;position: relative;} /* The animation changes the opacity from 0 to 1 in half a second, and, 3 seconds later, changes it back to 0, again in half a second (between 33.33% and 37.33%). Each slide starts its animation 4 seconds after the preceding slide. That means each slide starts fading in exactly as the previous slide starts fading out. (33.33% of 12 seconds is 4 seconds.) 2 slides: 4 seconds each, 8 seconds total, each one has 50% of the total time 3 slides: 4 seconds each, 12 seconds total, each one has 33.33% of the total time (4% of 12s = 0.48s transition time) 4 slides: 4 seconds each, 16 seconds total, each one has 25% of the total time (3.125% of 16s = 0.5s transition) 5 slides: 4 seconds each, 20 seconds total, each one has 20% of the total time (2.5% of 20s = 0.5s) 6 slides: 4 seconds each, 24 seconds total, each one has 16.66% of the total time (2.08% of 24s = 0.5s) 7 slides: 4 seconds each, 28 seconds total, each one has 14.29% of the total time (1.79%) 8 slides: 4 seconds each, 32 seconds total, each one has 12.5% of the total time (1.5625%) 9 slides: 4 seconds each, 36 seconds total, each one has 11.11% of the total time (1.389%) 10 slides: 4 seconds each, 40 seconds total, each one has 10% of the total time (1.25%) */ @keyframes crossfade-3-slides { 0% {opacity: 0.0} 4% {opacity: 1.0} 33.33% {opacity: 1.0} 37.33% {opacity: 0.0} 100% {opacity: 0.0} } @keyframes crossfade-4-slides { 0% {opacity: 0.0} 3.125% {opacity: 1.0} 25% {opacity: 1.0} 28.125% {opacity: 0.0} 100% {opacity: 0.0} } @keyframes crossfade-5-slides { 0% {opacity: 0.0} 4% {opacity: 1.0} 20% {opacity: 1.0} 24% {opacity: 0.0} 100% {opacity: 0.0} } @keyframes crossfade-6-slides { 0% {opacity: 0.0} 4% {opacity: 1.0} 16.66% {opacity: 1.0} 20.66% {opacity: 0.0} 100% {opacity: 0.0} } @keyframes crossfade-7-slides { 0% {opacity: 0.0} 4% {opacity: 1.0} 14.29% {opacity: 1.0} 18.29% {opacity: 0.0} 100% {opacity: 0.0} } Features: Allows you to leverage the tried and tested Osu! Beatmap Editor to create and playtest your own .osu files before importing them into Unity. Use community-made tools such as Mapping Tools to tweak your .osu files. Hit Objects are pooled and re-used, minimizing garbage allocation while playing. Uses SDF technique for rendering curves, allowing smooth thick curves. Customize gameplay rules. MouseDance API allows you to hook your own code into the game to change how it plays in many ways. The demo scenes include different examples. Works on desktop, mobile, and WebGL."
  },
  "manual/beatmap_canvas.html": {
    "href": "manual/beatmap_canvas.html",
    "title": "Beatmap Canvas | MouseDance User Docs",
    "keywords": "Beatmap Canvas MouseDance uses the Unity UI to render the Hit Objects (instead of the sprite system). This is so it can take advantage of the Canvas Scaler , so that we can translate Osu!pixels to Unity properly, no matter the screen resolution or aspect ratio. The reason for this is because Osu! is played on a 4:3 area, traditionally in 640x480 screen resolution. Even modern-day Osu! still uses a 4:3 area, it is just automatically enlarged to fit your screen. So when you make an .osu file, all the x and y positions of Hit Objects are within a 640x480 area. We can make this system work easily with Unity by having the Canvas Scaler 's Reference Resolution set to 640x480. That way, the position of Hit Object prefabs can be assigned with Osu!pixel values as-is, without worrying about the user's current screen resolution. Note This Reference Resolution is already prepared for you in the demo scenes, so you should use those as a starting point. This page is not a step-by-step instruction, it is only meant to help explain the rationale behind why the UI Canvas is set up the way it is. In the screenshots below, the blue box represents the Beatmap Area in varying screen sizes. This is that 640x480 that has been enlarged to fit the screen and centered, regardless if the user is playing in widescreen or ultra-widescreen. That means Hit Objects will only show up inside the blue box. When in portrait mode (i.e. mobile), the Beatmap Area has been set up so that it is anchored to the bottom. The rationale behind this being that when the user is holding a phone, it's easier for their fingers to reach the bottom portion of the screen. But you can change the anchoring of the RectTransform to whatever you want. Beatmap Area Adjuster You can optionally assign a different offset from the bottom of the screen depending on the specific aspect ratio using the BeatmapAreaAdjuster . In the screenshots below, the 3rd screen (1080x1920, with 9:16 aspect ratio) is given a higher offset than the rest. Hit Object Area Hit Objects are actually placed inside a smaller enclosed area inside that 640x480, where it is smaller by 10% on all sides. That means despite the fact that it's a 640x480 area, the furthest you can place a Hit Object in the Osu! Beatmap Editor is (511, 383) (note: not (512, 384) because position values start at 0). This ensures that no part of the Hit Object is ever partially off-screen. That also means that a Hit Object with x and y values at (0, 0) is really positioned at (64, 48) in the 640x480 area. Note that the position x and y is the center of the Hit Object. At the largest Circle Size setting allowed by the Osu! Beatmap Editor, a Hit Circle positioned at (0, 0) is just barely touching the top of the screen, so it isn't allowed to go any further. Same goes for a Hit Circle positioned at (511, 383), it is touching the bottom edge of the screen, and isn't allowed to go further below. (Note that the Unity Inspector will show the Pos Y at -383 because of how the Unity UI anchoring system works, we require the Y position to be negative.)"
  },
  "manual/beatmap_runner.html": {
    "href": "manual/beatmap_runner.html",
    "title": "Beatmap Runner | MouseDance User Docs",
    "keywords": "Beatmap Runner The Beatmap Runner is the brains of MouseDance. It takes care of loading an .osu file, starting the Beatmap, and playing the song. It keeps track of the song's current playtime to figure out when to spawn new Hit Objects on screen. Since this is a MonoBehaviour , this would exist in the scene as a component inside a GameObject, most often named \"Beatmap Runner\" itself, to make it self-descriptive. The BeatmapRunner requires to be assigned with three properties in the Inspector: Hit Object Manager, Audio Source, and Mouse Input Camera. The Beatmap Runner makes use of the Hit Object Manager , which handles prefab instantiation and pooling, so that the instantiated prefabs are reused as much as possible. Hit Object Manager handles which prefab is instantiated for which type of Hit Object. The Audio Source is needed so BeatmapRunner can play (and pause if necessary) the beatmap's song. This is separate from the AudioSource for the sound effects, so that you can have separate volume controls for music and sounds, thanks to Audio Mixers . The demo scenes are already set up for you such that music and sounds are in separate AudioGroups. The Mouse Input Camera is needed so BeatmapRunner knows where to do a raycast from, when checking which Hit Objects are under the mouse cursor. In the demo scenes, this uses the UI Camera, since all Hit Objects are rendered onto the Unity UI. There isn't anything special about this Camera . It's the typical set up for a Camera that's used to render Unity UI , where it is stacked onto the Main Camera. Warning If you are using a different render pipeline you will have to set up the cameras differently. If you are using HDRP for example, then refer to the notes on HDRP Multiple camera setup . Beatmap Runner also handles user-input. By default it is hardcoded to detect left mouse button or Z on the keyboard. It can use either the old or new Input System, whichever is available. It should be relatively easy to swap that out for however you detect user-input. You can implement IBeatmapInput , to change how it checks for user-input. The demo scene 5-Left Right Click Demo has an example of a class that customizes input (see LeftRightClickDemoMain ). See Custom User-Input Detection for more info. There are many other things in the Beatmap Runner that you can customize. Refer to the Code Usage page for more info."
  },
  "manual/code_usage.html": {
    "href": "manual/code_usage.html",
    "title": "Code Usage | MouseDance User Docs",
    "keywords": "Code Usage Tip This section is meant for experienced developers who are comfortable with programming in Unity. If you are unfamiliar with programming, or you don't understand the source code examples here, please refer to Unity's Learn platform first. The simplest way you can get a beatmap to run from code looks like this: public class BasicUsage : UnityEngine.MonoBehaviour { public MouseDance.Runtime.BeatmapRunner _beatmapRunner; public UnityEngine.TextAsset _osuFile; public UnityEngine.AudioClip _song; void Start() { _beatmapRunner.LoadAndStart(_osuFile, _song); } } Caution Take note that the BeatmapRunner needs to have been set up properly for this to work. To make this easier, a Basic Setup prefab is available for you to use in the MouseDance/Demo/Prefabs folder. You can also look at the demo scenes to see how it all works. After your code calls LoadAndStart , the BeatmapRunner will handle everything. Refer to the other sections on how to customize particular aspects of the game: Countdown Animation Customizing the Beatmap Getting Game Over Event and Results Custom User-Input Detection Custom Scoring Custom Hit Objects Custom Hit Rules Custom Circle Size Warning A note to developers: If you find yourself needing to change the source code inside MouseDance to fit your needs, please contact me first (contact details are in the asset package). The problem is if you edit MouseDance internal code, and then need to update it to a newer version, you would have to manually resolve the differences between your edits and the newer version of MouseDance. The proper way to customize MouseDance is using the API: implementing interface callbacks and/or sub-classing and overriding virtual methods. All the sample code shown do it this way. This is more desirable so that your code is separate from the MouseDance internal code. So if you need to, contact me and I can perhaps create a new virtual method that you can override, a new callback or event that you can subscribe to, or whatever works best for you."
  },
  "manual/custom_beatmap.html": {
    "href": "manual/custom_beatmap.html",
    "title": "Customizing the Beatmap | MouseDance User Docs",
    "keywords": "Customizing the Beatmap You can tweak any value in the Beatmap by implementing IBeatmapLoaded : public class BasicUsage : UnityEngine.MonoBehaviour, MouseDance.Runtime.Callbacks.IBeatmapLoaded { public MouseDance.Runtime.BeatmapRunner _beatmapRunner; public UnityEngine.TextAsset _osuFile; public UnityEngine.AudioClip _song; void Start() { _beatmapRunner.SetOnBeatmapLoaded(this); _beatmapRunner.LoadAndStart(_osuFile, _song); } public void OnBeatmapLoaded(OsuParsers.Beatmaps.Beatmap beatmap) { // Mimic the effects of Hard Rock modifier: beatmap.DifficultySection.CircleSize *= 1.3f; beatmap.DifficultySection.ApproachRate *= 1.4f; beatmap.DifficultySection.HPDrainRate *= 1.4f; beatmap.DifficultySection.OverallDifficulty *= 1.4f; // Flip Hit Objects vertically: const float CENTER_Y = MouseDance.Runtime.GraphicsUtil.OSU_PIXELS_CENTER_Y; var hitObjects = beatmap.HitObjects; for (int i = 0, len = hitObjects.Count; i < len; i++) { var pos = hitObjects[i].Position; pos.y = ((pos.y - CENTER_Y) * -1) + CENTER_Y; hitObjects[i].Position = pos; if (hitObjects[i] is OsuParsers.Beatmaps.Objects.Slider slider) { // if this is a Slider, do the same thing for the Slider Points for (int p = 0, pCount = slider.SliderPoints.Count; p < pCount; p++) { var sliderPoint = slider.SliderPoints[p]; sliderPoint.y = ((sliderPoint.y - CENTER_Y) * -1) + CENTER_Y; slider.SliderPoints[p] = sliderPoint; } } } } } Note that BeatmapRunner.SetOnBeatmapLoaded is called before starting the beatmap. OnBeatmapLoaded is called right before the song starts. It is only called once for every .osu file that has just been loaded. It is not called repeatedly when the song is restarted. The list of all Hit Objects is in beatmap.HitObjects . You can edit this freely, even remove from the list or add to it. Warning If your OnBeatmapLoaded doesn't seem to be getting called, check if you've properly called BeatmapRunner.SetOnBeatmapLoaded . For every BeatmapRunner, there can be only one active IBeatmapLoaded in use. BeatmapRunner in the Inspector will show you which callbacks have been registered. The one labeled IBeatmapLoaded should be green once the game is running. The name of the registered callback's concrete type will be displayed (namespace and class name). If it is a MonoBehaviour type, it'll show the actual file instead. You can click on that to ping it in the Project tab. This GUI is only for debugging. It is not designed or intended to register callbacks from the GUI."
  },
  "manual/custom_circle_size.html": {
    "href": "manual/custom_circle_size.html",
    "title": "Custom Circle Size | MouseDance User Docs",
    "keywords": "Custom Circle Size Circle Size is normally a constant value throughout the Beatmap, but with some simple tweaks, you can change it however you want. The proper way to do this is to implement IHitObjectSizeCalculator : public class BasicUsage : UnityEngine.MonoBehaviour, MouseDance.Runtime.Callbacks.IHitObjectSizeCalculator { public MouseDance.Runtime.BeatmapRunner _beatmapRunner; public UnityEngine.TextAsset _osuFile; public UnityEngine.AudioClip _song; void Start() { _beatmapRunner.SetHitObjectSizeCalculator(this); _beatmapRunner.LoadAndStart(_osuFile, _song); } public float GetHitCircleRadius(int idx, int comboCounter, int comboColourIdx, OsuParsers.Beatmaps.Objects.HitCircle hitCircle, OsuParsers.Beatmaps.Beatmap beatmap) { return GetDiminishingRadius(idx, comboCounter, beatmap); } public float GetSliderCircleRadius(int idx, int comboCounter, int comboColourIdx, OsuParsers.Beatmaps.Objects.Slider slider, OsuParsers.Beatmaps.Beatmap beatmap) { return GetDiminishingRadius(idx, comboCounter, beatmap); } static float GetDiminishingRadius(int idx, int comboCounter, OsuParsers.Beatmaps.Beatmap beatmap) { // get the last combo counter for this Hit Object int lastComboCounter = comboCounter; int lastComboIdx = idx; while (lastComboIdx+1 < beatmap.HitObjects.Count && !beatmap.HitObjects[lastComboIdx+1].IsNewCombo) { ++lastComboCounter; ++lastComboIdx; } float percentToCombo = (float)comboCounter / lastComboCounter; // We will return higher Circle Size (i.e. smaller radius) the closer we are to completing the combo. // We'll lerp between the radius values, instead of the Circle Size. This will give a smoother transition. float largest = MouseDance.Runtime.BeatmapUtil.GetCircleRadius(0); float smallest = MouseDance.Runtime.BeatmapUtil.GetCircleRadius(10); return UnityEngine.Mathf.Lerp(largest, smallest, percentToCombo); } } Note that BeatmapRunner.SetHitObjectSizeCalculator is called before starting the beatmap. The GetHitCircleRadius and GetSliderCircleRadius methods are called for every Hit Circle and Slider displayed on-screen. The return values there should be the circle radius in Osu!pixels , not the 0 to 10 Circle Size Difficulty value. If you want to convert a Circle Size value to the radius it represents, use BeatmapUtil.GetCircleRadius . Despite all that, MouseDance will only do minimal safety checks on the return value. You can return 1000 if you really want. But if you return 0 or negative, MouseDance will change back to using the radius as determined by the .osu file's Circle Size setting. Tip If you were trying to hide/remove a Hit Object by setting its size to 0, it's better if you instead remove that Hit Object altogether by directly editing the list of Hit Objects in the Beatmap data using OnBeatmapLoaded . See Customizing the Beatmap for an example. Warning If your custom code don't seem to be getting used, check if you've properly called BeatmapRunner.SetHitObjectSizeCalculator . For every BeatmapRunner, there can be at most only one active IHitObjectSizeCalculator in use. BeatmapRunner in the Inspector will show you which callbacks have been registered. The one labeled IBeatmapInput should be green once the game is running. The name of the registered callback's concrete type will be displayed (namespace and class name). If it is a MonoBehaviour type, it'll show the actual file instead. You can click on it to ping it in the Project tab. This GUI is only for debugging. It is not designed or intended to register callbacks from the GUI."
  },
  "manual/custom_countdown.html": {
    "href": "manual/custom_countdown.html",
    "title": "Countdown Animation | MouseDance User Docs",
    "keywords": "Countdown Animation If you want a countdown animation to run at the correct moment, such that it finishes right before the first Hit Object appears, implement ISongStartCountdown in your class like this: public class BasicUsage : UnityEngine.MonoBehaviour, MouseDance.Runtime.Callbacks.ISongStartCountdown { public MouseDance.Runtime.BeatmapRunner _beatmapRunner; public UnityEngine.TextAsset _osuFile; public UnityEngine.AudioClip _song; public UnityEngine.Animator _countdownAnimator; public UnityEngine.AnimationClip _countdownAnimationClip; public void OnStartCountdown() { _countdownAnimator.Play(\"Play\", -1, 0); } public float CountdownLength => _countdownAnimationClip.length; void Start() { _beatmapRunner.SetSongStartCountdown(this); _beatmapRunner.LoadAndStart(_osuFile, _song); } } Tip You will need to have your own countdown animation prepared beforehand. The Demo folder in MouseDance provides a simple countdown animation that you can use. Note that BeatmapRunner.SetSongStartCountdown is called before starting the beatmap. This will make your OnStartCountdown be called automatically by the BeatmapRunner at the right moment. You can put any code in there that you want. It could be an animation, a sound, etc. BeatmapRunner needs to know how long your countdown is (in seconds) so that is what the CountdownLength property is for. The reason is because it will take the absolute time for when the first Hit Object will appear, then deduct the CountdownLength from that. Thats the moment when the BeatmapRunner will call your OnStartCountdown . Meaning, if you specify 0 for CountdownLength , then OnStartCountdown will be called exactly when the first Hit Object starts to appear. If you specify 2.5f for CountdownLength , then OnStartCountdown will be called 2.5 seconds before the first Hit Object appears. Note that the .osu file can optionally specify a three-second period of silence added before the song plays, with the Lead-in property, so that will be taken into account. If in case your countdown animation takes too long and will not fit within the time allotted (even with Lead-in turned on), then MouseDance will automatically add the needed duration of silence. Warning If your OnStartCountdown doesn't seem to be getting called, check if you've properly called BeatmapRunner.SetSongStartCountdown . For every BeatmapRunner, there can be at most only one active ISongStartCountdown in use. BeatmapRunner in the Inspector will show you which callbacks have been registered. The one labeled ISongStartCountdown should be green once the game is running. The name of the registered callback's concrete type will be displayed (namespace and class name). If it is a MonoBehaviour type, it'll show the actual file instead. You can click on that to ping it in the Project tab. This GUI is only for debugging. It is not designed or intended to register callbacks from the GUI."
  },
  "manual/custom_hit_objects.html": {
    "href": "manual/custom_hit_objects.html",
    "title": "Custom Hit Object Spawning Rules | MouseDance User Docs",
    "keywords": "Custom Hit Object Spawning Rules If you want to have different shaped Hit Circles within the same Beatmap depending on some custom rules, you'll need to sub-class HitObjectSet and override GetHitCirclePrefab and/or GetSliderPrefab : [UnityEngine.CreateAssetMenu(fileName=\"MyHitObjectSet\", menuName=\"MouseDance/MyHitObjectSet\")] public class MyHitObjectSet : MouseDance.Runtime.HitObjectSet { public MouseDance.Runtime.HitCircle SpecialHitCirclePrefab; // Called by HitObjectManager whenever it needs to instantiate a Hit Circle, // as requested by BeatmapRunner, when it deemed that a new Hit Circle needs to be displayed due to the Beatmap. public override (string, MouseDance.Runtime.HitCircle) GetHitCirclePrefab(int idx, int comboCounter, int comboColourIdx, OsuParsers.Beatmaps.Objects.HitCircle hitCircle, OsuParsers.Beatmaps.Beatmap beatmap) { if ((idx+1) % 2 == 0) { // even number: use the special kind of hit circle return (\"even\", SpecialHitCirclePrefab); } else { // odd number: use the regular kind of hit circle return (\"odd\", HitCirclePrefab); } } public override (string, MouseDance.Runtime.Slider) GetSliderPrefab(int idx, int comboCounter, int comboColourIdx, OsuParsers.Beatmaps.Objects.Slider slider, OsuParsers.Beatmaps.Beatmap beatmap) { // change this however you want return (SliderPrefab.name, SliderPrefab); } } This code example will make Hit Object Manager alternate between two different prefabs when spawning Hit Circles. In this example, odd-numbered are circles, even-numbered are squares. Tip If what you wanted instead was to change all Hit Circles to a different prefab, then there's no need to do this code. Just assign your prefab to the HitObjectSet file. See Testing a Hit Circle Prefab Variant for an example. Creating the script is only half of the solution. Since this is a ScriptableObject type, you need to create an asset of this sub-class in your Project folder. The UnityEngine.CreateAssetMenu attribute we added in the sample code above makes this easy as it adds an entry in the Project tab's plus button: Since this is a sub-class of HitObjectSet , it will look mostly the same as a HitObjectSet in the Inspector, save for the new SpecialHitCirclePrefab field we added, found at the very bottom. Now we need to assign values to the fields. Unfortunately, the concept of Prefab Variants doesn't apply to Scriptable Objects, so we can't just specify our MyHitObjectSet file (the sub-class) to inherit values from a HitObjectSet file (the base class). That is why the Copy/Paste buttons were added. This is to make it quicker to assign values to the base fields of our MyHitObjectSet file, copying values from the HitObjectSet file. It is a simple matter of finding and selecting the pre-made HitObjectSet file in MouseDance/Prefabs folder, clicking Copy, then going back to your MyHitObjectSet file, and clicking Paste. This operation is recorded in the undo history, so you can undo it if you made a mistake. Now the only thing you need to manually assign is that new SpecialHitCirclePrefab field found in the sub-class MyHitObjectSet . For this example, you can use the pre-made custom Hit Circle called Hit Square from the MouseDance/Demo/Prefabs/Custom Hit Objects folder. Note You can refer to Creating a Hit Circle Prefab Variant for details on how to make your own Hit Circle. Assign the custom Hit Circle in the SpecialHitCirclePrefab field, and it should be ready. The last thing you need to do is assign that MyHitObjectSet into the HitObjectManager of your scene. Pool ID It should be noted that in the sample source code given in this page, not only did we return a Hit Circle Prefab, we also returned a string denoting what type it was (odd or even). This is important because the prefabs are pooled and reused, and the Hit Object Manager needs to be able to differentiate between the two types of Hit Circles. It uses that string to do so. If you are sure that the prefab names in your project are unique among each other, then you can simply use the Prefab name as the way to differentiate them from each other: return (HitCirclePrefab.name, HitCirclePrefab); Please note that the Prefab being referred to here is a prefab asset, before instantiation happens. It's not a prefab that is existing on the scene (yet). So the Prefab name here is its filename in your Project, not a GameObject name."
  },
  "manual/custom_hit_rules.html": {
    "href": "manual/custom_hit_rules.html",
    "title": "Custom Hit Object Collecting Rules | MouseDance User Docs",
    "keywords": "Custom Hit Object Collecting Rules You can add your own rules on whether the player is allowed to collect a Hit Object or not after clicking on it, or changing what sound and visual effects are used upon collecting a Hit Object based on some rule. using System.Collections.Generic; using MouseDance.Runtime; using UnityEngine; public class BasicUsage : UnityEngine.MonoBehaviour, Callbacks.IBeatmapInput, Callbacks.ICustomCollectRule { public BeatmapRunner _beatmapRunner; public UnityEngine.TextAsset _osuFile; public UnityEngine.AudioClip _song; void Start() { _beatmapRunner.SetInput(this); _beatmapRunner.SetHitObjectPress(this); _beatmapRunner.LoadAndStart(_osuFile, _song); } // Note: We're using the old/legacy Input System in this example, // but you can change this to whatever you want. // // Allow either left or right click. public bool IsPlayerInputDown => Input.GetMouseButtonDown(0) || Input.GetMouseButtonDown(1); public bool IsPlayerInputUp => Input.GetMouseButtonUp(0) || Input.GetMouseButtonUp(1); public Vector2 CursorPosition => Input.mousePosition; public HitObjectReaction AllowCollect(IHitObject hitObject, IReadOnlyList<IHitObject> allPressed) { // This struct will be our return value. // By default, the values in it will permit the Hit Object to be clicked on, // but we can disallow it instead, based on conditions. var result = HitObjectReaction.Default; // For example, we can make it that even-numbered Hit Objects // require to be right-clicked (not left-clicked) if ((hitObject.ComboCounter % 2) == 0) { // even-numbered, require right-click if (Input.GetMouseButtonDown(1)) { // ReactType.Proceed will permit the Hit Object to be clicked on, // but that is not a guarantee that it will be collected, // since the player is still subject to the usual rules // (needing to click within the proper time window, // needing to click on Hit Objects in the proper order). // It only means we're allowing it to proceed. // // This is already the default value of our ReactType, // we're just assigning it here for // illustrative purposes. result.ReactType = ReactType.Proceed; // we can also tell MouseDance to use a different sound and visual effect result.EffectsId = \"EvenHit\"; } else // player didn't right-click { // ReactType.Shake will prevent the Hit Object from being collected, // even if the player clicked within the proper time window. // It will also do a shaking animation. result.ReactType = ReactType.Shake; // we'll also use a different sound and visual effect on miss result.EffectsId = \"EvenMiss\"; } } else { // odd-numbered, require left-click if (Input.GetMouseButtonDown(0)) { result.ReactType = ReactType.Proceed; } else // player didn't left-click { result.ReactType = ReactType.Shake; } } return result; } public bool AllowCollectSliderPart(IHitObject slider) { if (Input.GetMouseButton(0) && Input.GetMouseButton(1)) { // player is holding both left and right mouse button, disallow this return false; } if ((slider.ComboCounter % 2) == 0) { // even-numbered, require right mouse button held return Input.GetMouseButton(1); } else { // odd-numbered, require left mouse button held return Input.GetMouseButton(0); } } } This example will require even-numbered Hit Objects to be right-clicked, and odd-numbered Hit Objects to be left-clicked. Note that to make this work properly, we implement two interfaces: IBeatmapInput (to allow both left and right click in the controls) and ICustomCollectRule (to change how Hit Objects are collected, based on the input). The AllowCollect method is used for adding custom rules on whether the player is allowed to collect the Hit Object they've clicked on. The HitObjectReaction.ReactType in the return value changes how the game reacts to the clicked Hit Object: td.word { vertical-align: top; text-align: right; min-width:150px; max-width:300px; } React Type Effect None Prevent Hit Object from being collected. No sound/visual effects will be played. The Hit Object will still be there (and the player can retry). Shake Prevent Hit Object from being collected, and make it do a shaking animation (with accompanying visual and sound effect). The Hit Object will still be there (and the player can retry). FadeOut Prevent Hit Object from being collected, and fade it out (with an accompanying sound effect). This will count as a miss. Since the Hit Object will disappear, the player will no longer be able to retry collecting the Hit Object. Proceed Allow the Hit Object to proceed as usual. This is not a guarantee that the Hit Object is collected, since that is still subject to the usual rules of needing to press within the timing window, and needing to click on the Hit Objects in the proper order. If you don't need to add custom rules, just return HitObjectReaction.Default . The AllowCollect method works on top of the usual rules that are already being followed (should be pressing Hit Objects in correct order, should press within the time window, etc.) so there is no need to repeat those basic rules in your AllowCollect method. AllowCollect is called during the same frame that IsPlayerInputDown returns true, provided that the code did find Hit Objects under the mouse cursor upon clicking. Furthermore, AllowCollect is called for each Hit Object under the mouse, in case the player clicked on overlapping Hit Objects. You can check the allPressed argument for the list of all Hit Objects pressed. This list is sorted by z-order, with the topmost Hit Object coming in first. That means you can check if the currently The AllowCollectSliderPart method is used when the player has their input down on a Slider and is about to collect a Slider Tick or Tail/Head. You can return false to prevent it from happening. Custom Hit/Miss Visual and Sound Effect The EffectsId in the return value can be used to make the game use a custom visual and sound effect. If you check the Hit Effects Set and Sound Effect Set , they allow specifying a custom visual effect and sound effect respectively. The ID assigned from there can be used for the EffectsId . So when you change the EffectsId to a value like \"EvenHit\" , it will look for that ID in both the Custom Visual Effect and Custom Sound Effect result.EffectsId = \"EvenHit\"; .cropHitEffect { max-width: 100%; height: 166px; overflow: hidden; margin: 5px; } .cropHitEffect img { max-width: 100%; height: 341px; margin-top: -176px; } .cropSoundEffect { max-width: 100%; height: 166px; overflow: hidden; margin: 5px; } .cropSoundEffect img { max-width: 100%; height: 500px; margin-top: -330px; }"
  },
  "manual/custom_input.html": {
    "href": "manual/custom_input.html",
    "title": "Customizing Input | MouseDance User Docs",
    "keywords": "Customizing Input By default, MouseDance just checks for left-click or Z on the keyboard. If you want to change it, the proper way to do this is to implement IBeatmapInput : using System.Collections.Generic; using MouseDance.Runtime; using UnityEngine; public class BasicUsage : UnityEngine.MonoBehaviour, Callbacks.IBeatmapInput { public BeatmapRunner _beatmapRunner; public UnityEngine.TextAsset _osuFile; public UnityEngine.AudioClip _song; public bool _relax; void Start() { _beatmapRunner.SetInput(this); _beatmapRunner.LoadAndStart(_osuFile, _song); } public bool IsPlayerInputDown { get { // Relax considers the user to be always pressing the button. if (_relax) return true; return Input.GetMouseButtonDown(0) || Input.GetKeyDown(KeyCode.Z); } } public bool IsPlayerInputUp { get { if (_relax) return false; return Input.GetMouseButtonUp(0) || Input.GetKeyUp(KeyCode.Z); } } public Vector2 CursorPosition => Input.mousePosition; } Note that BeatmapRunner.SetInput is called before starting the beatmap. Warning If your custom controls don't seem to be getting used, check if you've properly called BeatmapRunner.SetInput . For every BeatmapRunner, there can be at most only one active IBeatmapInput in use. BeatmapRunner in the Inspector will show you which callbacks have been registered. The one labeled IBeatmapInput should be green once the game is running. The name of the registered callback's concrete type will be displayed (namespace and class name). If it is a MonoBehaviour type, it'll show the actual file instead. You can click on that to ping it in the Project tab. This GUI is only for debugging. It is not designed or intended to register callbacks from the GUI."
  },
  "manual/custom_scoring.html": {
    "href": "manual/custom_scoring.html",
    "title": "Customizing Scoring | MouseDance User Docs",
    "keywords": "Customizing Scoring By default, MouseDance is doing only a simple score * combo counter * difficulty formula for scoring. If you want to change it, the proper way to do this is to implement IBeatmapScoreCalculator : Warning MouseDance has no HP Drain functionality yet, so it can't take that into account in the scoring formula for now (check the Roadmap and Release Notes for updates to this). It also has no Game modifiers yet, so that is also not included in the score formula. As it is, it can't exactly do the same scoring formulae in Osu! . public class BasicUsage : UnityEngine.MonoBehaviour, MouseDance.Runtime.Callbacks.IBeatmapScoreCalculator { public MouseDance.Runtime.BeatmapRunner _beatmapRunner; public UnityEngine.TextAsset _osuFile; public UnityEngine.AudioClip _song; void Start() { _beatmapRunner.SetScoreCalculator(this); _beatmapRunner.LoadAndStart(_osuFile, _song); } public int CalculateScore(MouseDance.Runtime.IHitObject hitCircle, int gotHitCircleValue, OsuParsers.Beatmaps.Beatmap beatmap) { int difficultyModifier = Mathf.RoundToInt((beatmap.DifficultySection.CircleSize + beatmap.DifficultySection.OverallDifficulty) / 38 * 5); // This is just following the wiki as close as I can, I honestly don't know where the 38 * 5 came from return gotHitCircleValue * (1 + ((hitCircle.ComboCounter-1) * difficultyModifier)); } public int CalculateScore(MouseDance.Runtime.IHitObject slider, int gotSliderHeadScore, int collectedSliderParts, int totalSliderParts, bool pressWasEverReleased, OsuParsers.Beatmaps.Beatmap beatmap) { // Out of the percent of collected vs total, this will return either 0, 50, 100, or 300: // 66% to 100%: 300 // 33% to 66% : 100 // >0 to 33% : 50 // 0% : 0 int sliderCompletionScore = BeatmapUtil.GetSliderBaseScore(collectedSliderParts, totalSliderParts); int sliderValue = 0; // Allow a 300 score only if the player got 300 when hitting the Slider's head, and never releasing their hold on the mouse button if (!pressWasEverReleased && sliderCompletionScore == 300 && gotSliderHeadScore == 300) { sliderValue = 300; } // Allow a 100 score only if the player also got at least 100 when hitting the Slider's head else if (sliderCompletionScore >= 100 && gotSliderHeadScore >= 100) { sliderValue = 100; } else if (sliderCompletionScore == 50) { sliderValue = 50; } int difficultyModifier = Mathf.RoundToInt((beatmap.DifficultySection.CircleSize + beatmap.DifficultySection.OverallDifficulty) / 38 * 5); // This is just following the wiki as close as I can, I honestly don't know where the 38 * 5 came from return sliderValue * (1 + ((slider.ComboCounter-1) * difficultyModifier)); } } Note that BeatmapRunner.SetScoreCalculator is called before starting the beatmap. Warning If your CalculateScore methods don't seem to be getting called, check if you've properly called SetScoreCalculator . For every BeatmapRunner, there can be at most only one active IBeatmapScoreCalculator in use. BeatmapRunner in the Inspector will show you which callbacks have been registered. The one labeled IBeatmapScoreCalculator should be green once the game is running. The name of the registered callback's concrete type will be displayed (namespace and class name). If it is a MonoBehaviour type, it'll show the actual file instead. You can click on that to ping it in the Project tab. This GUI is only for debugging. It is not designed or intended to register callbacks from the GUI."
  },
  "manual/dependencies.html": {
    "href": "manual/dependencies.html",
    "title": "Dependencies | MouseDance User Docs",
    "keywords": "Dependencies The MouseDance demo scenes make use of the Universal Render Pipeline , though this is not a strict requirement. With some amount of work, you can swap the shaders used in the demo to use the built-in render pipeline, or even HDRP. You would also have to change how the cameras are set up. URP was used simply because it was an easy way to showcase the demos. MouseDance displays Hit Objects on-screen using Unity UI (not the sprite system). MouseDance can use both the old and new Input System. It will use whichever is available, and it should be relatively easy to swap that out for whatever input-detection code you use. Implement IBeatmapInput to change how it checks for user-input. See Custom User-Input Detection for more info. MouseDance also uses TextMesh Pro , used in the display of numbers in the Hit Objects, and for the UI of the demos. The main third-party library used by MouseDance is OsuParsers , an MIT-licensed C# library that reads files in the .osu format. MouseDance relies on this so it can read the data from an .osu file and spawn the corresponding Hit Object as needed. A modified copy of the OsuParsers library is already included inside. The modifications are minor and merely designed to make it work easier with Unity (usage of System.Numerics.Vector2 was changed to UnityEngine.Vector2 , usage of System.Drawing.Color was changed to UnityEngine.Color32 ). These modifications are also available online at AnomalousUnderdog/OsuParsers ."
  },
  "manual/folder_layout.html": {
    "href": "manual/folder_layout.html",
    "title": "Folder Layout | MouseDance User Docs",
    "keywords": ".folder { border-radius: 3px; background-color: rgb(62,62,62); color: rgb(255, 153, 0); display: inline-block; padding: 0 3px; margin: 0 2px; white-space: nowrap; } .flex-container { display: flex; } .flex-container > div { padding: 0 0 10px 0; } Folder Layout Demo Files that show how MouseDance can be used. These include images, songs, source code, etc. You can delete these and/or keep the files that you want for your own game. Demo/Animation Contains a sample Ready, Get Set, Go! kind of UI animation, used in the beginning of the demos. You could swap this out for your own 3, 2, 1 countdown animation, or perhaps even a progress bar kind of animation. You could also just do away with any countdown animation altogether, but that isnt recommended as it doesnt give players any warning to prepare themselves. Demo/Images Contains sprites used for a custom-shaped Hit Circle, used in the demos. Demo/Materials Contains material needed for a custom Slider Ball, used in the demos. Demo/MouseCursor Custom Mouse Cursor textures, used in the demos. Demo/Prefabs Prefabs used by the demo scenes. These are examples on how a Beatmap Runner and Beatmap Canvas is set up, as well as custom Hit Object prefabs. You can use them as-is, or change them to your needs. Demo/Scenes All the scenes for the demos. The scenes are numbered, in more or less increasing amounts of complexity in its usage of Osu! mechanics. Demo/Scripts Code used by the demos to show how MouseDance is used. Look through here to see the code needed to load an .osu file, start the game, pause it, get the players score in the end in order to display it, etc. Demo/Songs Sample songs and .osu files used by the demos. The songs are courtesy of Kevin MacLeod , licensed in Creative Commons 4.0. Demo/Sounds Different kinds of sound effects used for hit/miss. These sound effects are all CC0 licensed. You could swap these out for your own sound effects, if you prefer. Docs Offline copy of the documentation as pdf files. Note that as pdf, the animated gif illustrations found in some manual pages won't be animated anymore. Fonts Contains font (and its TextMesh Pro materials) used in the display of numbers inside Hit Objects, as well as the text in the UI of the demos. This is in the Open Font License , and so should be fine for use in your own game. Images Images and sprites used in the display of Hit Objects, and the particle effects for hit/miss. You can swap these images with your own, if you prefer. Materials Materials used for the Hit Objects, and hit/miss particle effects. Models Contains a simple sphere 3d model, used by Sliders to show a ball rolling through them. Prefabs Prefabs of the Hit Objects, and hit/miss particle effects. Scripts Code required to make MouseDance work. Scripts/Editor Contains editor scripts to make editing some ScriptableObjects easier, an editor script to allow the BeatmapRunner to show diagnostic info in the Inspector, and an editor script to make Unity recognize .osu files in the project as text files. Scripts/InspectorUtil Contains simple PropertyDrawers to make editing of some properties easier. Scripts/OsuParsers The main third-party library needed. This is used to read the data inside .osu files. Slightly modified to make it work easier with Unity (usage of System.Numerics.Vector2 was changed to UnityEngine.Vector2 , usage of System.Drawing.Color was changed to UnityEngine.Color32 ). These modifications are also available online at AnomalousUnderdog/OsuParsers . Scripts/PennerEasing A simple tween library. This is a minor dependency, only used to make some animations of Hit Objects smooth and aesthetically-pleasing. This is not strictly needed. You can even remove it if you want, as long as you edit the MouseDance code to use different tweening formulae. This code is found online at Robert Penner's Easing Functions . Scripts/Runtime Actual MouseDance code. This mainly facilitates the spawning and display of Hit Objects, and user-input detection. Shaders Shader files needed to make the SDF curves in MouseDance work. This is used by the Sliders."
  },
  "manual/getting_results.html": {
    "href": "manual/getting_results.html",
    "title": "Getting Results | MouseDance User Docs",
    "keywords": "Getting Results If you want to be notified of when the Beatmap has ended (whether the player won or not), implement IBeatmapEnd in your class like this, and make sure to call SetBeatmapEnd before LoadAndStart : public class BasicUsage : UnityEngine.MonoBehaviour, MouseDance.Runtime.Callbacks.IBeatmapEnd { public MouseDance.Runtime.BeatmapRunner _beatmapRunner; public UnityEngine.TextAsset _osuFile; public UnityEngine.AudioClip _song; void Start() { _beatmapRunner.SetBeatmapEnd(this); _beatmapRunner.LoadAndStart(_osuFile, _song); } public void OnBeatmapEnd(MouseDance.Runtime.IBeatmapResults results) { print(results.PlayerWin ? \"Player Won!\" : \"Player Lost!\"); print($\"Score: {results.Score}\"); var hitObjects = results.HitObjects; for (int n = 0, len = hitObjects.Count; n < len; ++n) { string type = hitObjects[n] switch { OsuParsers.Beatmaps.Objects.HitCircle _ => \"Hit Circle\", OsuParsers.Beatmaps.Objects.Slider _ => \"Slider\", _ => \"Hit Object\" }; string hit = results.WasHit(n) ? \"Hit\" : \"Miss\"; print($\"Hit Object {n+1}/{len} ({type}): {hit}\"); } } } Note that BeatmapRunner.SetBeatmapEnd is called before starting the beatmap. Your OnBeatmapEnd will be called automatically by the BeatmapRunner when the game ends. You'll get an IBeatmapResults that gives information on the player's score, which Hit Objects they hit or miss, how accurate they were, etc. It's up to you how you want to display that information. The demo scenes have sample code that shows the score getting displayed in the GUI. Warning If your OnBeatmapEnd doesn't seem to be getting called, check if you've properly called BeatmapRunner.SetBeatmapEnd . BeatmapRunner in the Inspector will show you which callbacks have been registered. The one labeled IBeatmapEnd should be green once the game is running. The name of the registered callback's concrete type will be displayed (namespace and class name). If it is a MonoBehaviour type, it'll show the actual file instead. You can click on that to ping it in the Project tab. This GUI is only for debugging. It is not designed or intended to register callbacks from the GUI."
  },
  "manual/hit_circles.html": {
    "href": "manual/hit_circles.html",
    "title": "Hit Circles | MouseDance User Docs",
    "keywords": "Hit Circles Hit Circle Prefabs are composed of mostly Unity UI Images . Creating a Hit Circle Prefab Variant Since they are Unity UI Images, it's straightforward to swap out the image files used for something custom. An easy way to go about this is to make a Prefab Variant of the Hit Circle Prefab, and override only the properties you need to. Tip Images used here should be white-coloured. That makes it easy for the game to give it any colour as needed by the Beatmap (the previews shown in the screenshots use yellow only for illustrative purposes). The prefab has 4 parts: .word { text-align: right; vertical-align: top; font-weight: bold; } 1. Border The border is separate from the circle because this can be colored differently from the circle itself. 2. Circle The inside of the circle. This is separate from the border because this can be colored differently from the border. 3. Combo Counter Text The number displayed on the Hit Circle. The important thing to note here is that it uses `Auto Size` so that it can be properly sized when the Hit Circle is resized in-game. 4. Approach Circle The large circle that slowly shrinks for indicating the Hit Circle's hit time. You can, for example, change the image used for any of the parts (or the font, in the case of the Combo Counter Text) and then save that into the Prefab Variant. Previewing Circle Size If you need to check how your Hit Circle looks like for each Circle Size value, you can use the preview buttons in the Inspector. Remember that Circle Size is a difficulty setting, so higher values mean more difficulty. In this case, higher Circle Size value means smaller Hit Object. Border Scale Adjust If the border image doesn't quite fit in certain sizes, you can adjust the border using the Border Scale At Smallest Circle Size property. At the default value of 1.0 for Border Scale At Smallest Circle Size : Notice the large gap between the circle and its border when at Circle Size 7 and beyond. Tip The problem illustrated here is already fixed and no longer an issue in the demo's prefabs. This section is just to explain the thought process behind how it was fixed in case you are using your own custom images and is facing the same problem. This happens because if you look at the source image for the border, it has some drop shadow effects outside the circle. Note The screenshots here make the Hit Circles look pixelated because they are highly zoomed-in. So technically, when the Hit Circle diameter is at 64 pixels (radius of 32 pixels), the border image's diameter has to be sized more than 64 pixels, to ensure that the drop shadow effects are outside the Hit Circle. That's why the RectTransform has -5 on all edges (negative value means it goes beyond its parent container). So it is sized 5 pixels larger than the actual Hit Circle on all sides: For reference, here is what it would have looked like without that -5 adjustment (when the border image's diameter is same as the circle image, at exactly 64 pixels): So the -5 adjustment is really needed here. The problem is that it doesn't work well when the Hit Circle gets smaller. The -5 values in the RectTransform are in pixels. So it's maintaining that 5 pixel distance even at extremely small Hit Circle sizes, where the drop shadow effect no longer needs 5 pixels. The solution is to have additional tweaking to the size when the Hit Circle gets smaller. That is what Border Scale At Smallest Circle Size property is for. It adjusts the RectTransform's scale . With Border Scale At Smallest Circle Size set to 0.65 , the problem is fixed: Note You can think of the the Border Scale as a percentage, so 0.65 should be read as 65%, meaning, at Circle Size 10 (which is at about 20 pixels in diameter), we reduce the border image's size even further, down to 65% of its original size. The scale adjustment is only applied when the Circle Size given is small enough, so it doesn't affect normal sizes. You can adjust exactly when the Border Scale starts being applied using the Start Border Scale After property. With the default value of 5 in Start Border Scale After , that means border scale adjustment only happens after Circle Size 5 (i.e. Circle Sizes 6 to 10). This adjustment is applied linearly: Circle Size Scale applied to Border Image 5 1.0 6 0.93 7 0.86 8 0.79 9 0.72 10 0.65 Testing the Prefab Variant To make use of your Prefab Variant, you can modify your HitObjectSet so it uses your Prefab Variant instead of the original. The default HitObjectSet used by the demo scenes is in the MouseDance/Prefabs folder. Hit Detection User-input detection is handled by the BeatmapRunner . All the Hit Circle needs is to have a Collider2D so that raycasts will catch it. Caution Right now, only CircleCollider2D and BoxCollider2D is supported. Since the only job of the Hit Circle's Collider is to be clicked on, it will not interact with the Physics system. This is mostly ensured by setting it as a Trigger. Since the Colliders are set up as Triggers, the Queries Hit Triggers setting needs to be turned on in the Physics 2D section of Project Settings. The Beatmap Runner Inspector will alert you with an error message if it's turned off."
  },
  "manual/hit_effects_set.html": {
    "href": "manual/hit_effects_set.html",
    "title": "Hit Effects Set | MouseDance User Docs",
    "keywords": "Hit Effects Set Similar to HitObjectSet , Hit Effects Set is a ScriptableObject asset that groups together all hit/miss visual effect prefabs. This is used by the Hit Object Manager to spawn the appropriate visual effects as needed. Custom Visual Effect Custom Visual Effect is used in custom rules. When customizing Collect Rules , you can optionally make the game use a custom visual effect. .cropHitEffect { width: 514px; height: 166px; overflow: hidden; } .cropHitEffect img { width: 514px; height: 341px; margin-top: -175px; }"
  },
  "manual/hit_object_colours.html": {
    "href": "manual/hit_object_colours.html",
    "title": "Hit Object Colours | MouseDance User Docs",
    "keywords": "Hit Object Colours A ScriptableObject asset that dictates what colours the Hit Objects will be, if the .osu file has no colours defined. Each entry/element in the list are the colors to use for that specific Combo Colour Index. If this list of colours is emptied, MouseDance will default to using plain white for the colour."
  },
  "manual/hit_object_container.html": {
    "href": "manual/hit_object_container.html",
    "title": "Hit Object Container | MouseDance User Docs",
    "keywords": "Hit Object Container A RectTransform on the scene where Hit Objects will be placed on. As explained in Hit Object Area , Hit Objects are placed onto a RectTransform that's 640x480 but smaller by 10% on all sides. This is what the Hit Object Manager uses as the container for all Hit Object prefabs."
  },
  "manual/hit_object_manager.html": {
    "href": "manual/hit_object_manager.html",
    "title": "Hit Object Manager | MouseDance User Docs",
    "keywords": "Hit Object Manager The Hit Object Manager is another MonoBehaviour type class needed to properly run the Beatmap. It takes care of instantiating the Hit Object prefabs and pools them for re-use. All properties have a short tooltip description to give you an idea what they are for: Check each sub-section for an explanation on each property: Hit Object Set - holds all the Hit Object prefabs Hit Effects Set - holds all the hit/miss visual effects prefabs Sound Effect Set - holds all the AudioClips of hit/miss sound effects Hit Object Colours - colours that instantiated Hit Object prefabs will be in Hit Object Settings - miscellaneous tweaks to instantiated prefabs Hit Object Container - where instantiated prefabs are parented to View Camera For Ball - camera used to determine the Osu!Pixel distance between the Slider Ball and the mouse cursor SDF Curve Properties - various properties that SDF Curves need to be displayed properly Canvas Scaler - needed to figure out how much scaling is needed on the hit/miss visual effects Audio Source - where sound effects are played"
  },
  "manual/hit_object_manager_audio_source.html": {
    "href": "manual/hit_object_manager_audio_source.html",
    "title": "Audio Source | MouseDance User Docs",
    "keywords": "Audio Source This is simply the AudioSource where sound effects are played. This is separate from the AudioSource for the music, so that you can have separate volume controls for music and sounds, thanks to Audio Mixers . The demo scenes are already set up for you such that music and sounds are in separate AudioGroups."
  },
  "manual/hit_object_manager_canvas_scaler.html": {
    "href": "manual/hit_object_manager_canvas_scaler.html",
    "title": "Canvas Scaler | MouseDance User Docs",
    "keywords": "Canvas Scaler This is a minor requirement, only needed so Hit Object Manager can scale the particle effects accordingly to the Hit Object's Circle Size. To do that, it also needs the UI Canvas Scaler."
  },
  "manual/hit_object_manager_view_cam_for_ball.html": {
    "href": "manual/hit_object_manager_view_cam_for_ball.html",
    "title": "View Camera For Ball | MouseDance User Docs",
    "keywords": "View Camera For Ball It's part of the rules to check how far the mouse cursor is from the Slider Ball. The rules assume a screen size of 640x480, but since the 4:3 area that the game is played on is automatically enlarged and centered on-screen (as explained in Beatmap Canvas ), the pixel distance between the mouse cursor and the Slider Ball needs to be translated into that 640x480 area. To do this, Hit Object Manager needs the Camera of the Unity UI Canvas that is used to display the Hit Objects. There isn't anything special about this Camera. It's the typical set up for a Camera that's used to render Unity UI , where it is stacked onto the Main Camera. Warning If you are using a different render pipeline you will have to set up the cameras differently. If you are using HDRP for example, then refer to the notes on HDRP Multiple camera setup . About the only thing to note here is that the UI Camera's Culling Mask is set only to UI (as is typical for a UI Camera)."
  },
  "manual/hit_object_set.html": {
    "href": "manual/hit_object_set.html",
    "title": "Hit Object Set | MouseDance User Docs",
    "keywords": "Hit Object Set A ScriptableObject asset that groups together all Hit Object prefab references in one file. Each property here is a prefab that will be instantiated onto the scene: Each property also has their own short tooltip description: This makes it easier to override with your own group of Hit Object prefabs by swapping out the HitObjectSet used by the HitObjectManager with your own: You can make your own HitObjectSet by clicking on the + button in the Project tab and choosing MouseDance > HitObjectSet . You can also just duplicate the existing HitObjectSet file in MouseDance/Prefabs/ and use that as a starting point:"
  },
  "manual/hit_object_settings.html": {
    "href": "manual/hit_object_settings.html",
    "title": "Hit Object Settings | MouseDance User Docs",
    "keywords": "Hit Object Settings A ScriptableObject asset that holds miscellaneous tweaks on instantiated prefabs."
  },
  "manual/hit_objects.html": {
    "href": "manual/hit_objects.html",
    "title": "Hit Objects | MouseDance User Docs",
    "keywords": "Hit Objects Refer to the sub-sections for each type of Hit Object: Hit Circles Sliders Slider Ball"
  },
  "manual/osu.html": {
    "href": "manual/osu.html",
    "title": "A note about the usage of Osu! | MouseDance User Docs",
    "keywords": "A note about the usage of Osu! Osu! itself is a copyrighted game, but its code is open-source (MIT licensed). If you are making an Osu! type game, about the only thing you cant do, is use the Osu! trademark, logo (and other related graphic resources), and its likeness for the name and look of your own game, but the mechanics and the game design of the rhythm game itself can be used (much in the same manner that there are lots of Guitar Hero/Rock Band style rhythm games out there). Warning MouseDance is not meant to be a 1:1 copy of Osu! (there is no account system, no ranking or leaderboard functionality or any online service, nor does it really ever intend to have any). It is meant more to add Osu! style rhythm game mechanics into your Unity game. Here is a quote from the author of Osu! back in 2016 ( link to full post ): Do you personally condone osu! clones? Let me clarify that it depends on what you mean by a clone. If youre going to use the osu! code and make a new game called gosu! then no. This will infringe our trademark and also be an ass move. If you want to make a music game with similar gameplay rules to osu!, then by all means go ahead! I borrowed the rules for each game mode from already existing games and to be honest I dont believe there should ever be copyright/patent placed on any kind of basic gameplay elements. F--- that noise. In short, if you want to make your own game, make your own game from scratch. I guarantee it will be a more satisfying experience for everybody! None of the original Osu! source code is actually used in the MouseDance source code, despite the fact that its also written in C#. Osu! was written to work in the .NET SDK alone. It would have been a lot more work retrofitting that code into Unity, compared to just coding the Osu! rhythm game mechanics from scratch in Unity already in the first place. A little history Osu! itself is based on the Nintendo DS game, Osu! Tatakae! Ouendan (\"Go! Fight! Cheer Squad\") made in 2005 by iNiS Corporation . People in the western market might be more familiar with the game Elite Beat Agents , made in 2006 by the same developers. Both of these Nintendo DS games, as well as Osu! , have very similar rhythm game mechanics. Screenshot of Osu! Tatakae! Ouendan"
  },
  "manual/project_settings.html": {
    "href": "manual/project_settings.html",
    "title": "Project Settings | MouseDance User Docs",
    "keywords": "Project Settings MouseDance requires no special tags or layers . At its minimum, MouseDance only needs the built-in layers. But if you want to make sophisticated set-ups where post-processing effects like bloom affect Hit Objects only (not affecting the rest of the GUI), then you will need additional layers to pull it off. The demo scenes provide ready-made examples for you. MouseDance should work fine with either .NET Framework (aka .NET 4.x) or .NET Standard for the API Compatibility Level . Physics 2D Package MouseDance needs the Physics 2D package enabled for Hit Object hit detection. This is enabled by default so it should not be a problem, but if your Project has it disabled for any reason, the Beatmap Runner in the Inspector will alert you with an error message if needed. You can re-enable it in the Package Manager Window. Physics 2D Settings MouseDance needs Queries Hit Triggers and Queries Start in Colliders to be turned on in the Physics 2D section of your Project Settings . These two settings are also on by default so it should not be a problem. But in case they are off, the Beatmap Runner in the Inspector will alert you with an error message if needed."
  },
  "manual/release_notes.html": {
    "href": "manual/release_notes.html",
    "title": "Release Notes | MouseDance User Docs",
    "keywords": "Release Notes Version 0.1 Initial Release. See Roadmap for details on what's missing and what's planned next."
  },
  "manual/roadmap.html": {
    "href": "manual/roadmap.html",
    "title": "Roadmap & Known Issues | MouseDance User Docs",
    "keywords": "Roadmap & Known Issues These are Osu! functionalities that are missing in MouseDance, that I will experiment and try to implement in upcoming versions, but no guarantees just yet at this point (in no particular order): Spinner type Hit Objects HP Drain (player can't lose right now), geki and katsu mechanics Arrows that point to next Hit Object More info on the GUI (accuracy reading, hit timing window feedback) Recognizing custom hit sounds (whistle, clap, finish) defined in the .osu file Game modifiers like Hidden, Flashlight, or Double Time Slider \"grow\" animation when it fades-in Fancier mouse cursor (trail and particle effects) Song selection screen Other things to do and experiment (no particular order): More info on Results screen (accuracy graph) Replay recording and playback Improvements on SDF Curve SDF Curve is not drawn properly (gets clipped) if the camera rendering it has a rotation Tighter mesh to reduce overdraw (optimization) Render Hit Circles with SDF Convert any image to SDF for use in Hit Circles More demos to show how MouseDance can be used"
  },
  "manual/scene_setup.html": {
    "href": "manual/scene_setup.html",
    "title": "Scene Setup | MouseDance User Docs",
    "keywords": "Scene Setup This explains the GameObjects and Prefabs used to get Beatmaps to run properly. There is no need to read through this if you just want to get a beatmap running. The demo scenes are already configured to run properly. This is just to explain the rationale behind how the scene and GameObjects are set up. Conceptually, you can group MouseDance into three things: The Beatmap Runner , which controls the logic The Hit Objects , which are various different prefabs instantiated onto the Beatmap Canvas The Beatmap Canvas , which is just a regular Unity UI Canvas, but configured in a way to make it work properly for Beatmaps .diagram { display: grid; justify-content: space-evenly; grid-template-columns: auto auto auto auto auto auto auto auto auto; grid-template-rows: 50px 10px 50px; grid-template-areas: '. box1 . box2 . box3 .' '. box1 arrow12 box2 arrow23 box3 .' '. box1 . box2 . box3 .'; margin: .2in 0; align-items: center; } .diagram > .box { border-radius: 8px; background: #231641; border: 2px solid #8E8EFF; padding: 10px; text-align: center; vertical-align: middle; font-size: 125%; } .diagram > .box > .box_description { font-size: 60%; } #arrow-right12 { position: relative; bottom: 1px; left: 3px; width: 90px; height: 52px; } #arrow-right23 { position: relative; bottom: 1px; left: 3px; width: 110px; height: 52px; } .arrow-text { position: relative; text-align: center; vertical-align: middle; } .images { display: grid; justify-content: space-evenly; grid-template-columns: auto auto auto; gap: 10px; } Beatmap Runner (and Hit Object Manager) instantiates Hit Objects are placed onto Beatmap Canvas"
  },
  "manual/sdf_curve_properties.html": {
    "href": "manual/sdf_curve_properties.html",
    "title": "SDF Curve Properties | MouseDance User Docs",
    "keywords": "SDF Curve Properties SDF Curve Container Similar to Hit Object Container , SDF Curves are placed onto the Hit Object Area . SDF Curve Camera Due to how SDF shapes are rendered on-screen, they need the UI Camera to be correctly sized. Canvas Same with how SDF shapes need the UI Camera, they also need the UI Canvas to be correctly sized when rendered on-screen. Screen Adjust As explained in Beatmap Area Adjuster , when in portrait mode (i.e. mobile), the screen can be adjusted to have a different bottom offset. SDF shapes need to know that bottom offset so they can adjust their position accordingly."
  },
  "manual/slider_ball.html": {
    "href": "manual/slider_ball.html",
    "title": "Slider Ball | MouseDance User Docs",
    "keywords": "Slider Ball Sliders feature a ball 3d model rolling through it. When a beatmap is played, only one Slider is \"active\" at a time, and therefore you only get to see one ball at any given time. So in reality, there is only one ball instantiated in the Unity scene. It is just reused, being moved from one Slider to another. 3d Model Different from all the other prefabs, this prefab holds a 3d model. To get it rendered properly in the UI, the layer of this 3D model GameObject is changed to UI, and we added a Sorting Group component to ensure it shows above the sprites and SDF Curves (in terms of z-order). Collider Same with Hit Circles, the Slider Ball uses a CircleCollider2D . It doesn't use a SphereCollider because being a 2D game, the three-dimensional aspect of a SphereCollider is useless, despite this showing a 3D model. The simpler CircleCollider2D is more than enough to work for hit detection of the Slider Ball. Roll Axis You can change which direction the ball does its rolling on. Note This rolling is only a visual effect, the collider does not really do any rolling. In fact the collider doesn't really interact with the physics system since its only job is to be used for hit detection with the mouse cursor and nothing more. You can choose to make it roll in more than one axis, but if you want to make it roll in a more traditional manner, you may want to ensure only one is toggled. Which axis to use depends on how the 3D model was oriented upon export from the software it was made on. If you're bringing a custom 3D model to be used as the Slider Ball, it's best to just figure this out by trial-and-error. You can even choose None to essentially prevent the ball from doing a rolling animation. It would just slide along the curve. Ball Scale Multiplier Since Unity UI regards distance units as pixels, there is a vast gap between the unit of measurement in Unity UI's 2D system vs 3D models. To be able to translate the Osu!pixel values we work with into the Slider Ball 3D model's scale, the Slider Ball component has a property called Ball Scale Multiplier . Depending on the size of your 3d model, this value can be quite small. In our default prefab for example, its value is 0.034117969 . This is basically the multiplier needed to get the ball 3d model properly sized on-screen. Basically, MouseDance will get the value for what the ball should be in, but it's in values that assume a 640x480 screen . A default sized ball for example (with Circle Size setting at 5), has a radius of 32 pixels. So we need a multiplier that brings this value of 32 into a scale value that's appropriate for our 3D model (since we use scale to change our 3D model size). 32 * 0.034117969 = 1.091775008  scale applied on the 3D model = (1.091775008, 1.091775008, 1.091775008) For the specific ball 3D model that we use, that multiplier happens to be 0.034117969 . This is mostly verified by trial and error adjustments. So if you have your own custom 3D model that you want to use, you may need to tweak the Ball Scale Multiplier in your own playtesting. Note This ball scale by the way, is for visual purposes only. The CircleCollider2D size (which works directly with Osu!pixel values) stays independent of this scale, so even if the ball looks too small or too big, the hit detection will still work the same."
  },
  "manual/sliders.html": {
    "href": "manual/sliders.html",
    "title": "Sliders | MouseDance User Docs",
    "keywords": "Sliders Slider Start and End Caps are displayed using the same technique as explained for Hit Circles . .SliderContainer { position: relative; top: 0; left: 0; } .SliderCap { position: relative; top: 0; left: 0; animation: HideShow 2s infinite steps(2, end); } .SliderBody { position: absolute; top: 0px; left: 0px; } @keyframes HideShow { from { visibility: hidden; } to { visibility: visible; } } @keyframes ShowHide { from { visibility: visible; } to { visibility: hidden; } } .SliderBodyText { position: relative; top: 0; left: 0; animation: ShowHide 2s infinite steps(2, start); } .SliderCapText { position: absolute; top: 0; left: 0; animation: HideShow 2s infinite steps(2, end); } Slider Without Caps Slider With Caps But the curve body of a Slider is rendered using a technique called Signed Distance Field. This produces accurate shapes even when the lines are thickened. While most of its visual properties can't be manually edited (e.g. curve thickness is controlled by the .osu file's Circle Size property, colours are controlled by the Hit Object Colours , there are some visual properties you can edit. In the MouseDance/Materials folder, you can edit the SDF Curve.mat . This is the material that the SDF Curve Prefab uses. Border Start and End Slider curves have a border surrounding it. You can change the thickness, move it closer to the center, or set the values to 0 if you dont want any border. Center Line Slider curves can optionally have a line at its center. Set this to -1.0 if you dont want it. Gradient Start and End Adjust Slider curves feature a gradient starting from the center of the line, going outward. You can adjust where the gradient starts and ends. These values are normalized. Start Adjust defaults at 1.0 . End Adjust defaults at 0.0 . Anti-aliasing Smoothness Slider curves come with their own built-in anti-aliasing. This is independent of your post-processing anti-alias. A value of 0.1 is more than enough. Too high and the curve will end up blurry, too low and it will have no effect."
  },
  "manual/sound_effect_set.html": {
    "href": "manual/sound_effect_set.html",
    "title": "Sound Effect Set | MouseDance User Docs",
    "keywords": "Sound Effect Set Similar to how the HitObjectSet works, SoundEffectSet is a ScriptableObject asset that groups together all sound effects used. Each one is played for a particular situation. Check the tooltip descriptions for more info. Warning MouseDance does not implement the recognition of custom hitsounds coming from the .osu file yet. Check the Roadmap and Release Notes for updates. Custom Sound Effect Custom Sound Effect is used in custom rules. When customizing Collect Rules , you can optionally make the game use a custom sound effect. .cropSoundEffect { width: 592px; height: 166px; overflow: hidden; } .cropSoundEffect img { width: 592px; height: 500px; margin-top: -330px; }"
  },
  "manual/terminologies.html": {
    "href": "manual/terminologies.html",
    "title": "Terminologies | MouseDance User Docs",
    "keywords": "Terminologies All further explanation requires you to be familiar with certain concepts in Osu! : td.word { vertical-align: top; text-align: right; min-width:100px; max-width:290px; } Hit Object Anything on screen that needs to be clicked on or touched (i.e. when playing on mobile) in time with the music. All Hit Objects have a number on them, indicating the order needed to press them. Hit Circle The simplest type of Hit Object. This is just a circle that needs to be clicked/pressed once. Most of the time, a group of Hit Circles will be shown in advance, requiring the player to click through them in fairly quick succession, but timed with the beat of the music. Slider A long line that serves as a Hit Object. This requires the player to hold the mouse button down and move the mouse cursor to follow alongside a ball that is automatically rolled through the Sliders path, in time with the music. There are different kinds of Sliders. Some are straight lines with sharp corners, some are wavy curves. Some will make the ball repeat movement back-and-forth the path once or twice. Beatmap A beatmap is the entirety of the Hit Objects, all positioned and timed properly to the beat of the song theyre meant for. Technically, a beatmap includes more, like images and/or video clips played alongside the song, custom hit sound effects, etc. but currently, MouseDance only takes in the Hit Object data. For the visuals, you can use something like Unitys Timeline instead to get a similar result. Collect As a verb, collecting is the act of clicking/pressing (or touching, for mobile) a Hit Object at the right moment and thus, adding to your score. This is sometimes used interchangeably with \"click\" or \"hit\", but \"collect\" is specifically when you click and didn't miss."
  },
  "manual/upgrading.html": {
    "href": "manual/upgrading.html",
    "title": "Upgrading and Best Practices Guide | MouseDance User Docs",
    "keywords": "Upgrading and Best Practices Guide When upgrading your copy of MouseDance to a newer version, always make a backup first. You may want to import the newer version into an empty project first and check what has changed. Unity's package importing works on file GUIDs instead of the file's path. That means even if you move a file to a new folder, the GUID stays the same, and if you import a newer version of that file (from a package), Unity will overwrite it even though it's not in its original location anymore. The package import process also doesn't have any diff checking functionality. When it detects a change, it's either you allow that file to be overwritten or not with a checkbox. Until the UPM format becomes the de-facto standard for Asset Store packages, this is what the importing experience is like. Don't modify MouseDance source code itself, make extensions The mentioned limitations with Unity mean it's best that you do not directly edit the source code of MouseDance. Instead, have your own code merely register callbacks to the MouseDance API and/or write a subclass of a MouseDance class that is meant to be subclassed. Keep that code in files that are your own, outside of the MouseDance folder. All sample code in the Code Usage section work this way. This ensures that when MouseDance files need to be overwritten by a version update, there wouldn't be any edits made by you that will be lost. In fact, even without Unity's limitations, this approach is still recommended, since it makes updating your copy of the MouseDance plugin be smooth and seamless. Warning A note to developers: If you find yourself deciding that you do need to change the source code inside MouseDance to fit your needs, please contact me first (contact details are in the asset package). I can perhaps create a new callback or event that you can subscribe to, a new virtual method that you can override, expose more properties, or whatever works best for you. Use Prefab Variants When it comes to prefabs, it's better to treat the prefabs that come with MouseDance in a read-only manner. If you want to customize them, either make a new prefab from scratch, duplicate the existing prefab, or better yet, make a Prefab Variant . With Prefab Variants, you can take advantage of the existing prefab structure, but at the same time have your edits be separate from the MouseDance plugin. This again ensures that when MouseDance prefabs need to be overwritten by a version update, there wouldn't be any edits made by you that will be lost. See Creating a Hit Circle Prefab Variant for an example. Make copies of ScriptableObjects The same workflow doesn't work for ScriptableObjects because they don't have any built-in equivalent to the Prefab Variant functionality. So if you want to make an edit to any of these ScriptableObject files, it is best to make a copy, and do the edits on your copies instead. MouseDance uses five types of ScriptableObjects, all used by HitObjectManager: .cropHitObjectManager { width: 542px; height: 181px; overflow: hidden; } .cropHitObjectManager img { width: 542px; height: 476px; } Hit Object Set - holds all the Hit Object prefabs Hit Effects Set - holds all the hit/miss visual effects prefabs Sound Effect Set - holds all the AudioClips of hit/miss sound effects Hit Object Colours - colours that instantiated Hit Object prefabs will be in Hit Object Settings - miscellaneous tweaks to instantiated prefabs"
  }
}